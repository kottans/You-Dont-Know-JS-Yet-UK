# Серія "Ти поки що не знаєш JS". Книга 1: "Перші кроки". Друге видання
# Глава 4: Загальна картина мови

Ця книга містить деякі відомості, необхідні тим, хто *починаєте* вивчати JS. Мета книги полягає в тому, щоб заповнити прогалини, з якими читачі, що знайомі з JS недавно, могли зіткнутися під час своїх перших зустрічей з мовою. Також я сподіваюся, що у цій книзі мені вдалося натякнули на досить глибокі деталі мови й тим самим викликати у вас цікавість та заохотити заглиблюватися у неї.

У решті книг серії ми роздивимося нюанси мови значно детальніше, ніж ми могли б у кількох коротких главах тут.

Не забувайте, що не варто поспішати. Замість того, щоб хапатися за наступну книгу, намагаючись пройти всі книги якомога швидше, краще витратьте деякий час на повторний перегляд матеріалу цієї книги. Перегляньте код у своїх поточних проєктах і порівняйте побачене з тим, про що ми говорили.

Коли ви будете готові, переходьте до останньої глави, яка спочатку виділить три основні опори організації JS як мови, а потім запропонує короткий огляд того, що можна очікувати від решти серії книг. Також ця глава містить мої рекомендації щодо подальшої роботи. Крім того, не пропускайте додатки, особливо Додаток Б, "Прийшов час практики!".

## Опора №1: Області видимості та замикання

Підхід до організації змінних в окремі області видимості (функційні, блокові) є однією з найбільш фундаментальних характеристик будь-якої мови; можливо, жодна інша характеристика не впливає на поведінку програм так сильно.

Області видимості схожі на відерця, а змінні – на скляні кульки, які ви розкладаєте по цих відерцях. Модель визначення областей видимості – це правила, які допомагають визначити, який колір кульок в яке відерце класти.

Області видимості вкладаються одна в одну. Будь-якому виразу чи інструкції доступні лише змінні на відповідному рівні вкладеності області видимості або з вищих (інакше – зовнішніх) областей видимості; змінні з нижчих (тобто, внутрішніх) областей видимості приховані та недоступні.

Ось як поводяться області видимості в більшості мов. Це називається лексичним визначенням областей видимості. Межі однієї області видимості та спосіб організації змінних в них визначається під час парсингу (компіляції) програми. Іншими словами, це рішення, яке приймає автор коду: від того, де ви розташуєте функцію чи область видимості в програмі, залежить, якою буде структура областей видимості цієї частини програми.

JS визначає область видимості лексично, хоча через дві особливості його моделі, яких немає в інших мовах з лексичною областю видимості, багато хто стверджує, що це не так.

Першу особливість зазвичай називають *підняття*: це коли всі змінні, оголошені в будь-якому місці області видимості, обробляються так, ніби вони оголошені на самому початку області видимості. Друга полягає в тому, що змінні, оголошені з `var`, мають функційну область видимості, навіть якщо вони з'являються в блоці.

Ані підняття, ані функційної області видимості змінних, оголошених з `var`, не достатньо для підтвердження думки про те, що JS не має лексичного визначення області видимості. Оголошення змінних з `let` та `const` мають особливу поведінку щодо помилок, яка називається "Тимчасова мертва зона" (ТМЗ), що призводить до появи видимих, але не доступних змінних. Хоча ТМЗ може видатися дивною поведінкою, це *також* не спростовує лексичного визначення області видимості. Все це лише унікальні частини мови, які слід засвоїти всім JS-розробникам.

Замикання є природним наслідком лексичного визначення області видимості, коли мова визнає функції значеннями першого класу, як це робить JS. Коли функція посилається на змінні з зовнішньої області видимості й ця функція передається як значення та виконується в інших областях видимості, вона зберігає доступ до змінних своєї первісної області видимості; це і є замикання.

У програмуванні, зокрема програмуванні на JS, замикання лежить в основі багатьох найважливіших шаблонів, включаючи модулі. Модулі, на мою думку, є найбільш природним способом організації JS-коду.

Щоб глибше розібратися з областями видимості, замиканнями та принципами роботи модулів, прочитайте Книгу 2, *Області видимості та замикання*.

## Опора №2: Прототипи

Друга опора мови – система прототипів. Ми розбираємо цю тему детально в главі 3 "Прототипи", але я хочу зробити ще кілька зауважень щодо її важливості.

JS - одна з небагатьох мов, де у вас є можливість створювати об'єкти безпосередньо та явно, без попереднього визначення структури цих об'єктів в класі.

Протягом багатьох років люди застосовували шаблон "Клас" поверх прототипів - для так званого "прототипного успадкування" (див. Додаток А, "Прототипні "класи""), а потім з появою ключового слова `class` в ES6 мова подвоїла свою схильності до програмування в об'єктно-орієнтованому чи класово-орієнтованому стилі.

Але я думаю, що поза увагою лишилися краса та потужність системи прототипів: можливість двох об'єктів просто з'єднуватися між собою та динамічно взаємодіяти під час виконання функції або методу через спільний контекст `this`.

Класи – це лише один з шаблонів, які ви можете побудувати поверх такої сили. Підхід, що пропонує рух в геть іншому напрямку, полягає в тому, щоб просто прийняти об’єкти самі по собі, забути про класи і дати об’єктам взаємодіяти через ланцюжок прототипів. Це називається делегуванням поведінки. Я думаю, що для організації поведінки та даних у наших програмах делегування є більш потужним засобом, ніж наслідування через класи.

Але наслідування, засноване на класах, отримує майже всю увагу. Решта приділяється функційному програмуванню (FP), як свого роду «антикласовому» способу проєктування програм. Мене це засмучує, бо це знищує будь-які шанси на вивчення делегування як життєздатної альтернативи.

Я закликаю вас витратити багато часу на Книгу 3, *Об'єкти та класи*, щоб побачити, як делегування до об'єктів має набагато більше потенціалу, ніж ми, можливо, усвідомлювали. Це не виступ проти класів, це твердження "класи не єдиний спосіб використовувати об'єкти", до якого я хочу привернути більше уваги JS-розробників.

Я готовий сперечатися, що делегування між об’єктами набагато природніше для JS, ніж класи (трохи більше про *природність* згодом).

## Опора №3: Типи та приведення типів

Третя опора – це та частина природи JS, яку, безумовно, ігнорують найчастіше.

Переважна більшість розробників мають хибні уявлення про те, як *типи* працюють в мовах програмування, і особливо про те, як вони працюють у JS. В ширшій JS-спільноті піднялася хвиля інтересу до статичної типізації з використанням спеціальних інструментів, що вміють працювати з типами, зокрема TypeScript та Flow.

Я погоджуюсь з тим, що JS-розробники мають знати більше про типи, а також про те, як JS обходиться з перетвореннями типів. Я також згоден, що інструменти для роботи з типами можуть допомогти розробникам, за умови, що вони перед використання інструментів здобули ті знання та використовують їх!

Але з чим я геть не згоден, так це з висновком, що начебто механізм типів у JS поганий і нам потрібно перекривати власні типи JS за допомогою сторонніх рішень. Нам не потрібно дотримуватися підходу «статичної типізації», щоб розумно та безпечно працювати з типами в наших програмах. Є й інші варіанти, якщо ви готові піти *проти думки більшості* та *за природою* JS (знову ж таки, про це далі).

Можливо, ця опора мови є важливішою за інші дві в тому сенсі, що жодна програма на JS не зробить нічого корисного, якщо вона не використовує належним чином типи значень JS та правила перетворення типів значень (приведення типів).

Навіть якщо ви любите TypeScript чи Flow, ви не зможете отримати від цих інструментів чи підходів до написання коду максимум користі, якщо ви не знайомі глибоко з тим, як сама мова управляє типами значень.

Щоб дізнатись більше про типи та приведення типів у JS, перегляньте Книгу 4, *Типи та граматики*. Але, будь ласка, не пропускайте цю тему лише тому, що ви завжди чули, що слід використовувати `===` і не перейматися через деталі.

Якщо ви не вивчите цю опору, фундамент знань ваших про JS буде хитким і в кращому випадку неповним.

## Згідно природі мови

Я маю пораду щодо продовження вашої навчальної подорожі з JS упродовж цієї та інших книг серії: тримайте в голові ідею *природності* (згадайте різні посилання на *природу* раніше в цій главі).

Спочатку розглянемо *природу* того, як більшість людей підходить до JS і використовує її. Ви, напевно, вже помітили, що ці книги багато в чому йдуть всупереч з розповсюдженим підходом. Я поважаю читачів серії "Ти поки що не знаєш JS" достатньо, щоб пояснити всі частини JS, а не лише деякі вибрані популярні теми. Я вірю, що ви здатні засвоїти ці знання і заслуговуєте на те, щоб їх почути.

Але це нетиповий підхід для навчальних матеріалів. Зокрема це означає, що чим більше ви будете дотримуватися вказівок з цих книг, коли ретельно обміркуєте їх і проаналізуєте, що саме буде найкраще для вашого коду, тим більше ви будете виділятися. Це може бути добре і погано. Якщо ви коли-небудь захочете вирватися з натовпу, вам доведеться відірватися від його типової поведінки!

Але мені також доводилося чути багатьох людей, які наводили якусь тему чи пояснення з цих книг під час співбесіди при найманні на роботу і чули від інтерв’юера, що вони помилялися. В результаті ці люди втрачали роботу.

В цих книгах я прагну за можливістю надати цілком точну інформацію про JS, як правило, прямо зі специфікації. Але я також додаю чимало своїх думок щодо того, як ви можете інтерпретувати та використовувати JS з найбільшою користю для своїх програм. Я не представляю ані власну думку як факт, ані навпаки. В цих книгах ви завжди знатимете, що є що.

Факти про JS насправді не підлягають дискусіям. Специфікація або стверджує щось, або ні. Якщо вам не подобається те, що сказано в специфікації, чи моя ретрансляція цього, звертайтеся до TC39! Якщо ви проходите співбесіду, і ваші інтерв'юєри стверджують, що ви не праві, запитайте їх, чи можете ви знайти підтвердження їхнім словам в специфікації. Якщо інтерв'юер не захоче перевірити, то вам так чи інше не варто працювати в цьому місті.

Але якщо ви вирішите поділяти мої думки, ви повинні бути готові аргументувати цей вибір, а не повторювати за мною, як папужка. Захищайте власну думку. Якщо хтось, з ким ви сподівались працювати, не погоджується, відійдіть з високо піднятою головою. JS велика мова, тут вистачить місця для безлічі різних підходів.

Іншими словами, не бійтеся йти проти течії, як я зробив з цими книгами та всіма своїми навчальними матеріалами. Ніхто не може сказати вам, як найкраще використовувати JS; це вам вирішувати. Я просто намагаюся дати вам можливість робити власні висновки, якими б вони не були.

З іншого боку, є *природа*, на яку вам справді слід звернути увагу та зважати: *природа* того, як працює JS на мовному рівні. Є речі, які працюють добре та природно в JS, враховуючи правильну практику та підхід, і є речі, які ви насправді на варто намагатися робити.

Чи можете ви зробити так, щоб ваша програма на JS виглядала як програма на Java, C # або Perl? А як щодо Python чи Ruby, або навіть PHP? До певного рівня так, звичайно, можете. Але чи варто?

Я думаю, що ні. Я думаю, вам слід навчитися і прийняти шлях JS і зробити свої JS-програми якомога природнішими для цієї мови, у межах можливого. Деякі подумають, що це означає недбале та неформальне програмування, але я зовсім не те маю на увазі. Я хочу сказати, що JS має багато власних характерних шаблонів та ідіом, і використання цього *природного підходу* у загальному випадку є шляхом до найбільшого успіху.

Нарешті, можливо, найважливішим *природним способом* є визнання того, як працюють наявні програми та розробники, з якими ви працюєте. Не намагайтеся після читання цих книг за одну ніч змінити *все* у своїх проєктах. Такий підхід завжди вестиме до поразки.

Вам доведеться змінювати речі потроху, з часом. Попрацюйте над досягненням консенсусу з колегами-розробниками щодо того, чому важливо повертатися та переглядати підхід. Але робіть це лише з однією невеликою темою за раз, і нехай результати порівняння коду до та після говорять за себе. Зберіть всіх членів команди для обговорення та наполягайте на прийнятті рішень, які базуються на аналізі та доказах з коду, а не на інерції "наші старші розробники завжди робили так".

Це найважливіша порада, яку я можу дати, щоб допомогти вам навчитися JS. Завжди продовжуйте шукати кращих способів використання того, що нам дає JS, для створення більш читабельного коду. Кожен, хто працює над вашим кодом, включаючи вас самих з майбутнього, подякує вам!

## По черзі

Отже, тепер у вас є ширший погляд на те, що належить дослідити в JS, і правильне ставлення до решти подорожі.

На цьому моменті мене часто питають, в якому порядку слід читати книги. Є очевидна відповідь... але вона не універсальна.

Моя порада для більшості читачів – пройти цю серію в такому порядку:

1. Почніть з закладення міцної основи JS з книгою *Перші кроки* (Книга 1) - хороша новина в тому, що її ви вже майже дочитали.

2. У книзі *Області видимості та замикання* (Книга 2) заглибтесь у вивчення першої опори JS. Дізнайтеся, що таке лексичні області видимості, як з ними пов'язані замикання та як шаблон "Модуль" допомагає організовувати код.

3. У книзі *Об'єкти та класи* (Книга 3) зосередьтеся на другій опорі JS: як працює `this` у JS, як прототипи об'єктів підтримують делегування та як прототипи роблять можливим використання механізму `class` для організації коду в об'єктно-орієнтованому стилі.

4. У главі *Типи та граматики* (Книга 4) розгляньте третю та останню опору JS: типи та зведення типів, а також те, як синтаксис та граматика JS визначають те, як ми пишемо наш код.

5. Після того, як три опори встануть на свої місця, *Синхронність та асинхронність* (Книга 5) досліджує, як ми використовуємо контроль потоку виконання для моделювання змін стану в наших програмах, як синхронних (одразу), так і асинхронних (з часом).

6. Серія завершується книгою *ES.Next і далі* (Книга 6), перспективним поглядом на найближче та середньострокове майбутнє JS, включаючи різноманітні функції, які, можливо, невдовзі з’являться у ваших програмах JS.

Я виходжу з того, що ви читатимете книги саме в такому порядку.

Однак книги 2, 3 та 4, зазвичай можна читати в будь-якому порядку, залежно від того, яка тема здається вам найцікавішою та зручною для вивчення у першу чергу. Але я не рекомендую вам пропускати будь-яку з цих трьох книг, навіть «Типи та граматики», як деякі з вас напевне захочуть, навіть якщо думаєте що вже опанували певну тему.

Книга 5 (*Sync & Async*) має вирішальне значення для глибокого розуміння JS, але якщо ви почнете розбиратися і виявите, що це вас занадто лякає, цю книгу можна відкласти, поки ви не отримаєте більше досвіду з мовою. Чим більше коду на JS ви написали (і чим більше проблем відчули на власному досвіді), тим більше ви оціните цю книгу. Тож не бійтеся повертатися до неї пізніше.

Завершальна книга серії, *ES.Next і далі*, стоїть певним чином осторонь. Її можна прочитати в кінці, як я пропоную, або одразу після *Перших кроків*, якщо ви шукаєте короткий шлях до розширення свого уявлення про JS. З великою ймовірністю ця книга буде оновлюватися в майбутньому, тому вам, мабуть, час від часу доведеться її перечитувати.

Однак, якщо ви вирішите продовжити роботу з YDKJSY, спершу ознайомтеся з додатками до цієї книги, зокрема попрактикуйтеся з Додатком  "Прийшов час практики!". Я вже говорив, що практика важлива? Немає кращого способу навчитися писати код, ніж писати його якомога більше.
