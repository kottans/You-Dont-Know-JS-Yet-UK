# Серія "Ти поки що не знаєш JS". Книга 2: Області видимості та замикання - Друге видання
# Глава 5: (Не такий вже і) таємний життєвий цикл змінних

Сподіваюся, на даний момент ви вже маєте хороше розуміння вкладеності областей видимості, від глобальної області видимості вниз: так званий ланцюжок областей видимості програми.

Але знання про те, з якої області видимості походить змінна - це лише частина історії. Якщо оголошення змінної з’являється після першої інструкції в області видимості, як поводитимуться посилання на цей ідентифікатор, що знаходяться *до* його оголошення? Що станеться, якщо ви спробуєте оголосити ту саму змінну в одній області видимості двічі?

Особливий підхід JS до лексичної організації області відімості має багато нюансів щодо того, як і коли змінні з’являються та стають доступними для коду програми.

## Коли можна використовувати змінну?

З якого моменту змінна стає доступною для використання в своїй області видимості? Відповідь може здатися очевидною: *після* оголошення чи створення. Хіба не так? Не зовсім.

Розглянемо приклад:

```js
greeting();
// Hello!

function greeting() {
    console.log("Hello!");
}
```

Цей код працює. Можливо, ви вже бачили або навіть самі писали щось подібне. Але чи задумувались ви колись над тим, як і чому він працює? Зокрема, чому ідентифікатор `greeting` доступний на рядку 1 (через нього ми отримуємо посилання на функцію та викликаємо її), хоча оголошення `greeting` відбувається лише на рядку 4?

Нагадаємо, в главі 1 зазначається, що всі ідентифікатори реєструються у відповідних областях видимості під час компіляції. Більше того, кожен ідентифікатор *створюється* на початку області видимості, до якої він належить, **щоразу, коли ми заходимо у цю область видимості**.

Термін, який найчастіше використовується для змінної, яка є видимою з самого початку навколишньої області видимості, хоча її оголошення може з'являтися нижче в області видимості, називається **підняттям**.

Але одне лише підняття не пояснює ситуацію остаточно. Нехай ідентифікатор `greeting` видимий на початку своєї області видимості, але як ми можемо **викликати** функцію `greeting` ще до того, як її оголошено?

Іншими словами, як змінна `greeting` на момент запуску області видимості вже містить якесь значення (посилання на функцію)? Відповідь в особливій характеристиці формальних оголошень `function`, яка називається **підняття функцій**. Коли ідентифікатор декларації `function` зареєстрований у верхній частині області видимості, він додатково автоматично ініціалізується посиланням на цю функцію. Ось чому функцію можна викликати будь-де в області видимості!

Однією з ключових деталей є те, що як **підняття функцій**, так і **підняття змінних**, оголошених з ключовим словом `var`, прикріплюють свої ідентифікатори імен до найближчої навколишньої **функційної області видимості**, (або глобальної, якщо функційну не знайдено), а не до блочної області.

| ПРИМІТКА: |
| :--- |
| Декларації з `let` і `const` також піднімаються (див. обговорення TDZ далі в цьому розділі). Але ці дві форми оголошень приєднуються до навколишнього блоку, а не просто до навколишньої функції, як у оголошеннях `var` та `function`. Докладнішу інформацію див. У розділі "Блочна область видимості" у розділі 6. |

### Підняття: в чому різниця між оголошенням та виразом

*Підняття функції* відбувається лише з формальними оголошеннями з ключовим словом `function` (зокрема тих, що з'являються поза блоками - див. "FiB" у розділі 6), а не до присвоєння виразів `function`. Розглянемо приклад:

```js
greeting();
// TypeError

var greeting = function greeting() {
    console.log("Hello!");
};
```

Рядок 1 (`greeting();`) видає помилку. Проте особливу увагу слід приділити *виду* помилки. `TypeError` означає, що ми намагаємось зробити щось із недозволеним значенням. Залежно від вашого середовища JS, повідомлення про помилку міститиме щось на зразок "'undefined' is not a function,", або корисніше "'greeting' is not a function."

Зверніть увагу, що помилка **не** `ReferenceError`. JS не каже, що не зміг знайти ідентифікатор `greeting` в області видимості. Натомість він каже, що `greeting` знайдено, але на потрібний момент ідентифікатор не містить посилання на функцію. Можна викликати лише функції, тому спроба викликати якесь нефункційне значення призводить до помилки.

Але яке значення містить `greeting`, якщо не посилання на функцію?

На додачу до сплиття змінні, оголошені за допомогою `var`, також автоматично ініціалізуються значеннм `undefined` на початку своєї області видимості - а саме найближчої навколишньої функції або глобальної області видимості. Одназу після ініціалізації вони доступні для використання (присвоєння, отримання значення тощо) у всій області видимості.

Отже, у цьому першому рядку `greeting` існує, але містить лише значення за замовчуванням `undefined`. Посилання на функцію буде призначене лише на рядку 4.

Зверніть пильну увагу на цю відмінність. Декларація функції з `function` піднімається **та ініціалізується її значенням** (повторю, що ця поведінка називається *підняття функції*). Змінна, оголошена з `var`, також піднімається, а потім автоматично ініціалізується значенням `undefined`. Будь-яке подальше присвоєння виразу `function` цій змінній не відбувається, поки це призначення не буде оброблено під час виконання.

В обох випадках ім'я ідентифікатора піднімається. Але посилання на функцію не обробляється під час ініціалізації (на початку області видимості), окрім випадків, коли ідентифікатор створений у формальному оголошенні з `function`.

### Підняття змінних

Розглянемо інший приклад *підняття змінної*:

```js
greeting = "Hello!";
console.log(greeting);
// Hello!

var greeting = "Howdy!";
```

`greeting` оголошено лише на рядку 5, але присвоєння можна виконувати вже на першому рядку. Чому так?

Хоча `привітання` оголошується лише на рядку 5, його можна призначити вже в рядку 1. Чому?

Пояснення складається з двох частин:

* ідентифікатор піднімається,
* **а також** автоматично ініціалізується до значенням `undefined` у верхній частині області видимості.

| ПРИМІТКА: |
| :--- |
| Використання *підняття змінних* такого роду, мабуть, здається неприродним, і багато читачів справедливо захочуть уникнути покладання на це у своїх програмах. Але чи слід уникати всякого підняття (включаючи *підняття функцій*)? Ми розглянемо різні точки зору на підняття більш детально в Додатку А. |

## Інша метафора підняття

Розділ 2 був досить насичений метафорами для ілюстрації областей видимості, але ось ще одна: підняття як таке. Замість того, щоб думати про підняття як про конкретний крок виконання, який виконує рушій JS, корисніше думати про підняття як про візуалізацію різних дій, які виконує JS під час налаштування програми **перед виконанням**.

Типове твердження про те, що означає підняття: щось подібне до підняття ваги *підйом* - як підняття важкої ваги вгору - будь-які ідентифікатори аж до вершини області видимості. Пояснення, яке часто наводять, полягає в тому, що рушій JS фактично *переписує* програму перед виконанням, так що вона буде виглядати приблизно так:

```js
var greeting;           // hoisted declaration
greeting = "Hello!";    // the original line 1
console.log(greeting);  // Hello!
greeting = "Howdy!";    // `var` is gone!
```

Англійське слово hoisitng описує підняття чогось за допомогою пристроїв, наприклад, лебідки. Таким чином запропонована метафора піднімання ваги передбачає, що JS якимось чином обробляє оригінальну програму і дещо перевпорядковує її так, що перед виконанням всі оголошення опиняються у верхній частині відповідних областей видимості. Більше того, метафора підняття ваги стверджує, що функції, оголошені з `function`, цілком розміщуються у верхній частині кожної області видимості. Розглянемо приклад:

```js
studentName = "Suzy";
greeting();
// Hello Suzy!

function greeting() {
    console.log(`Hello ${ studentName }!`);
}
var studentName;
```

Далі метафора підняття передбачає певний порядок: спочатку піднімаються оголошення функцій, а одразу після цього піднімаються змінні. Отже, історія з підняттям говорить про те, що програма *реорганізується* рушієм JS, щоб виглядати приблизно так:

```js
function greeting() {
    console.log(`Hello ${ studentName }!`);
}
var studentName;

studentName = "Suzy";
greeting();
// Hello Suzy!
```

Метафора підняття зручна. Її перевага в тому, що вона дозволяє прикрити очі на магічну природу попередньої обробки, яка потрібна для того, щоб знайти всі ці декларації, закопані глибоко в області видимості, і якось перемістити (тобто, підняти) на верх області видимості; ми можемо і далі думати, ніби програма виконується рушієм JS за **один прохід**, зверху вниз.

Виконання за один прохід, безумовно, здається простішим, ніж твердження про двофазну обробку з глави 1 .

Підняття як механізм повторного впорядкування коду здається привабливим спрощенням, але ця метафора не є точною. Рушій JS ніяк не переупорядковує код. Він не вміє чарівним чином заглядати вперед і знаходити декларації; єдиним способом їх надійного знаходження всіх декларацій, а також усіх меж областей видимості в програмі – це повний парсинг коду.

А що таке парсинг? Так це ж і є перша фаза двофазної обробки! Тож, ніякі розумові трюки не дозволяють обійти цей факт.

Але якщо метафора підняття у кращому випадку просто неточна, що нам робити з цим терміном? Я вважаю, що він лишається корисним. Справді, навіть члени TC39 регулярно ним користуються! Але я не думаю, що нам слід наполягати на тому, що йдеться про справжню реорганізацію вихідного коду.

| ПОПЕРЕДЖЕННЯ: |
| :--- |
| Неправильні або неповні ментальні моделі часто здаються достатніми, оскільки можуть випадково давати правильні відповіді. Але якщо ваше мислення не зовсім узгоджується з тим, як працює рушій JS, в довгостроковій перспективі стає важче точно аналізувати та прогнозувати результати  |

Я наполягаю на тому, що слово "підняття" *слід* використовувати для посилання на **операцію часу компіляції**, а саме на формування інструкцій з автоматичної реєстрації змінної на початку відповідної області видимості при кожному вході у цю область видимості під час виконання.

Це тонкий, але важливий зсув у розумінні: від уявлення про підняття як про поведінку часу виконання до підняття як одного з завдань часу компіляції, де його справжнє місце.

## Повторне декларування?

Як ви думаєте, що відбувається, коли змінна оголошується більше одного разу в одній області видимості? Розглянемо приклад:

```js
var studentName = "Frank";
console.log(studentName);
// Frank

var studentName;
console.log(studentName);   // ???
```

Як думаєте, що буде виведене у другому випадку? Багато хто вважає, що `var studentName` повторно оголосило змінну (і, таким чином, "скинуло" її значення), тому очікують, що буде виведено `undefined`.

Але чи є такий процес, що дозволяє  "повторно оголошення" змінної в тій самій області видимості? Ні.

Якщо розглядати цю програму з точки зору метафори підняття, код буде реорганізований наступним чином перед виконанням:

```js
var studentName;
var studentName;    // очевидно марна операція, яка нічого не робить!

studentName = "Frank";
console.log(studentName);
// Frank

console.log(studentName);
// Frank
```

Since hoisting is actually about registering a variable at the beginning of a scope, there's nothing to be done in the middle of the scope where the original program actually had the second `var studentName` statement. It's just a no-op(eration), a pointless statement.

Оскільки підняття насправді стосується реєстрації змінної на початку області видимості, то в середині області видимості, де оригінальна програма містить другий оператор `var studentName`, робити вже нічого. Це безглузда інструкція, яка нічного не робить.

| ПОРАДА: |
| :--- |
| У контексті уявної розмови між компілятором та менеджером області видимості з глави 2 *Компілятор* знайшов би друге твердження декларації `var` і запитав *Менеджера області видимості*, чи він вже бачив ідентифікатор `studentName`; оскільки він вже бачив, більше нема чого більше робити. |

Важливо також зазначити, що `var studentName;` не те саме що `var studentName = undefined;`, як вважають більшість. Доведемо, що вони різні, розглянувши такий варіант програми:

```js
var studentName = "Frank";
console.log(studentName);   // Frank

var studentName;
console.log(studentName);   // Frank <--- так, нічного не змінилося!

// додамо явну ініціалізацію
var studentName = undefined;
console.log(studentName);   // undefined <--- як вам таке!?
```

Подивіться, як явна ініціалізація `= undefined` дає інший результат, ніж ми то, що ми мали отримати, якщо припускаємо, що ініціалізація відбувається неявно, коли не вказано? У наступному розділі ми знову повернемося до теми ініціалізації змінних з їх оголошень.

Повторне оголошення `var` з тим самим іменем ідентифікатора в області видимості є фактично непрацюючою операцією. Ось ще одна ілюстрація, цього разу для функції з однойменною назвою:

```js
var greeting;

function greeting() {
    console.log("Hello!");
}

// нічого не робить
var greeting;

typeof greeting;        // "function"

var greeting = "Hello!";

typeof greeting;        // "string"
```

Перше оголошення `greeting` реєструє ідентифікатор в області видимості, і оскільки це `var`, автоматично ініціалізацію значенням `undefined`. Оголошення `function` не потребує повторної реєстрації ідентифікатора, але через *підняття функції* воно замінює значення, присвоєне під час автоматичної ініціалізації, на посилання на функцію. Друге `var greeting` саме по собі нічого не робить, оскільки `greeting` вже є ідентифікатором і *підняття функції* вже взяла пріоритет для автоматичної ініціалізації.

Фактично присвоєння значення `"Hello!"` змінній `greeting` змінює його значення з початкової функції `greeting()` на рядок; `var` сам по собі не має жодного ефекту.

А як щодо повторної декларації в одній області видимості з `let` або` const`?

```js
let studentName = "Frank";

console.log(studentName);

let studentName = "Suzy";
```

Ця програма не буде виконуватися, натомість негайно видасть `SyntaxError`. Залежно від вашого середовища JS, повідомлення про помилку звучатиме приблизно так: "studentName has already been declared.", тобто, "studentName вже оголошено." Іншими словами, це випадок, коли спроба "повторного декларування" явно не дозволяється!

Справа не лише в тому, що дві декларації, що включають `let`, викинуть цю помилку. Якщо в будь-якій декларації використовується `let`, інша може бути `let` або `var`, і помилка все одно буде виникати, як доводять нам ці дві варіації:

```js
var studentName = "Frank";

let studentName = "Suzy";
```

and:

```js
let studentName = "Frank";

var studentName = "Suzy";
```

В обох випадках `SyntaxError` з'являється після другої декларації. Іншими словами, єдиним способом "повторного оголошення" змінної є використання `var` для всіх (двох або більше) її оголошень.

Але навіщо було забороняти повторне оголошення? Причина очевидно не в технічних обмеженнях, оскільки "повторне декларування" змінних, оголошених з `var`, завжди дозволялося; очевидно, що такий саме допущення можна було зробити і для `let`.

Це насправді питання "соціальної інженерії". Деякі, в тому числі багато хто з комітету TC39, сприймають "повторне оголошення" змінних як шкідливу звичку, яка може призвести до помилок у програмі. Тож коли ES6 представив `let`, вони вирішили запобігти "повторному декларуванню" за допомогою помилки.

| ПРИМІТКА: |
| :--- |
| Звичайно, йдеться про стилістичний переваги, а не технічні. Багато розробників погоджуються з позицією, і це, мабуть, частково, чому TC39 включив помилку (а також `let` відповідати `const`). Але міг бути обґрунтований випадок, що дотримуватися прецеденту `var` було більш розсудливим, і що таке примушення до думки краще залишити на виборі таких інструментів, як лінери. У Додатку А ми дослідимо, чи може `var` (та пов'язана з нею поведінка, як-от "повторне оголошення") бути корисним у сучасному JS. |

Коли *Компілятор* питає *Менеджера області видимості* щодо декларації, якщо цей ідентифікатор вже оголошений, і якщо будь-яка чи обидві декларації були зроблені з `let`, виникає помилка. Призначений сигнал розробнику: "Перестань покладатися на недбале повторне оголошення!"

### А що з константами?

Ключове слово `const` має більше обмежень, ніж `let`. Як і `let`, в одній області видимості не можна використати `const` більше одного разу з однаковим ідентифікатором. Але насправді є важлива технічна причина, через яку такий вид "повторного декларування" заборонений, на відміну від `let`, який забороняє "повторне декларування" переважно зі стилістичних причин.

Ключове слово `const` вимагає ініціалізації змінної, тому якщо ви оголошуєте змінну з `const`, але не присвоюєте їй значення, виникає` SyntaxError`:

```js
const empty;   // SyntaxError
```

Оголошення змінної з `const` створює змінну, значення якої не можна призначити повторно:

```js
const studentName = "Frank";
console.log(studentName);
// Frank

studentName = "Suzy";   // TypeError
```

Змінна `studentName` не може отримати інше значення, бо оголошена за допомогою `const`.

| ПОПЕРЕДЖЕННЯ: |
| :--- |
| Помилка, що виникає при повторному призначенні `studentName`, є `TypeError`, а не `SyntaxError`. Відмінність тонка, проте досить важлива, але, на жаль, її легко пропустити. Синтаксичні помилки являють собою помилки в програмі, які зупиняють її навіть у початковому виконанні. `TypeError` стосуються помилок, які виникають під час виконання програми. У попередньому фрагменті, `"Frank"` буде виведено до того, як відбудеться обробка повторного призначення `studentName`, яке призводить до помилки |

Отже, якщо декларації через `const` не можуть бути перепризначені, а декларації через `const` завжди вимагають призначення, тоді у нас є чітка технічна причина, чому `const` не дозволяє  "повторні декларації": будь-яке `const` "повторне оголошення" водночас означає повторне призначення, що не можна допускати!

```js
const studentName = "Frank";

// obviously this must be an error
const studentName = "Suzy";
```

Оскільки "повторне декларування" змінних, оголошених з `const`, має бути заборонено (з означених технічних підстав), TC39 по суті вважав, що для несуперечливості також слід заборонити "повторне декларування" змінних, оголошених з `let`. Можна посперечатися щодо того, чи це найкращий вибір, але принаймні ми знаємо аргументи, що стоять за цим рішенням.

### Цикли

Тож з попереднього обговорення ясно, що JS насправді не хоче, щоб ми «повторно оголошували» наші змінні в тій самій області видимості. Це, мабуть, здається простим застереженням, поки ви не задумаєтесь, що це означає для повторного виконання операторів декларації у циклах. Розглянемо приклад:

```js
var keepGoing = true;
while (keepGoing) {
    let value = Math.random();
    if (value > 0.5) {
        keepGoing = false;
    }
}
```

Чи "оголошується" змінна `value` кілька разів у цій програмі? Чи ми отримаємо помилки? Ні.

Усі правила області видимості (зокрема, заборона на "повторне оголошення" змінних, оголошених з `let`) застосовуються *для кожного окремого екземпляра області видимості*. Іншими словами, щоразу при вході в область видимості попередні оголошення скидаються.

Кожна ітерація циклу створює окремий екземпляр області видимості, і в кожному екземплярі області видимості  `value` оголошується лише один раз. Отже, немає спроб "повторного декларування", а отже, і помилок. Перш ніж ми розглянемо інші форми циклу, припустимо, що, декларацію `value` у попередньому фрагменті змінено на `var`:

```js
var keepGoing = true;
while (keepGoing) {
    var value = Math.random();
    if (value > 0.5) {
        keepGoing = false;
    }
}
```

Чи змінна `value` «повторно оголошується», тим більше, що ми знаємо, що `var` це дозволяє? Ні. Оскільки `var` не трактується як декларація блочної області видимості (див. Главу 6), вона приєднується до глобальної області видимості. Отже, є лише одна змінна `value`, яка знаходиться в тій же області видимості, що і `keepGoing`  (у цьому випадку глобальна область аидимості). Тут також немає жодної "повторної декларації"!

Один із способів все це зрозуміти - пам’ятати, що ключові слова `var`, `let`, та `const` насправді *видаляються* з коду до того моменту, коли він починає виконуватися. Вони повністю обробляються компілятором.

Спробуйте подумки стерти ключові слова оголошення, а потім спробуйте обробити код, це повинно допомогти вам вирішити, чи можуть відбуватися (повторні) оголошення і в яких випадках.

А як щодо "повторного оголошення" з іншими видами циклів, наприклад `for`?

```js
for (let i = 0; i < 3; i++) {
    let value = i * 10;
    console.log(`${ i }: ${ value }`);
}
// 0: 0
// 1: 10
// 2: 20
```

Повинно бути зрозуміло, що для кожного екземпляра області видимості оголошується лише одна `value`. Але як щодо `i`? Її оголошують повторно?

Щоб відповісти на це питання, розгляньте, в якій області видимості знаходиться `i`. Може здатися, що вона буде у зовнішній (у даному випадку глобальній) області, але це не так. Це в межах тіла циклу `for`, як і `value`. Насправді ви могли б уявити цей цикл так:

```js
{
    // видумална зміння для демонстраційних цілей
    let $$i = 0;

    for ( /* тут порожно */; $$i < 3; $$i++) {
        // а ось тут справжня `i` з циклу!
        let i = $$i;

        let value = i * 10;
        console.log(`${ i }: ${ value }`);
    }
    // 0: 0
    // 1: 10
    // 2: 20
}
```

Тепер повинно бути зрозуміло: змінні `i` та `value` оголошуються рівно один раз **для кожного екземпляру області видимості**. Ніякого "повторного декларування" тут немає.

А як щодо інших форм циклу `for`?

```js
for (let index in students) {
    // тут все добре
}

for (let student of students) {
    // як і тут
}
```

З циклами `for..in` та` for..of` те саме: оголошена змінна обробляється наче вона *всередині* тіла циклу, і таким чином обробляється за ітерацію (тобто, в межах окремого екземпляру області). Ніякого "повторного декларування".

Добре, я знаю, ви думаєте, що у мене платівку заїло. Але давайте дослідимо, як `const` впливає на ці цикли. Розглянемо код:

```js
var keepGoing = true;
while (keepGoing) {
    // ooo, a shiny constant!
    const value = Math.random();
    if (value > 0.5) {
        keepGoing = false;
    }
}
```

Подібно до варіанту цієї програми з `let`, який ми бачили раніше, декларація з `const` виконується рівно один раз в межах окремої ітерації циклу, тому ми захищені від проблем із "повторним оголошенням". Але все ускладнюється, коли ми говоримо про цикл `for`.

`for..in` і `for..of` добре використовувати з `const`:

```js
for (const index in students) {
    // все добре
}

for (const student of students) {
    // і тут також
}
```

Проте зі звичайним циклом `for` справі гірші:

```js
for (const i = 0; i < 3; i++) {
    // ой, це код викине помилку
    // Type Error після першої ітерації
}
```

Що тут не так? Ми могли б використати `let` просто чудово в цій конструкції, і ми стверджували, що він нова `i` створюється для області видимості кожної ітерацій циклу, тому це навіть не здається "повторним оголошенням".

Давайте подумки «розширимо» цей цикл, як робили раніше:

```js
{
    // видумална зміння для демонстраційних цілей
    const $$i = 0;

    for ( ; $$i < 3; $$i++) {
        // а ось тут справжня `i` з циклу!
        const i = $$i;
        // ..
    }
}
```

Вже помітили проблему? Наша `i` справді створена один раз у циклі. Не в цьому проблема. Проблема полягає в концептуальному `$$i`, яку потрібно щоразу збільшувати за допомогою виразу `$$i++`. Це **пере-призначення** (а не «повторне декларування»), що не допускається для констант.

Пам’ятайте, що ця «розширена» форма - це лише концептуальна модель, яка допоможе вам зрозуміти джерело проблеми. Ви можете спитати себе, чи міг JS сам перетворити `const $$ i = 0` на `let $ ii = 0`, що дозволило б тоді `const` працювати з нашим класичним циклом `for`? Це можливо, але тоді це могло ввести потенційно дивовижні винятки з семантики циклу `for`.

Наприклад, було б досить довільним (і заплутаним) винятком, якщо дозволити `i++` у заголовку циклу `for` зменшити строгість призначення `const`, але не дозволити інші перепризначення `i` всередині ітерації циклу, що іноді корисно.

Пряма відповідь така: `const` не може використовуватися з класичною формою циклу `for` через необхідність перепризначення.

Цікаво, що якщо ви не зробите повторне призначення, то код працює:

```js
var keepGoing = true;

for (const i = 0; keepGoing; /* nothing here */ ) {
    keepGoing = (Math.random() > 0.5);
    // ..
}
```

Це працює, але це код не має сенсу. Немає жодної причини оголошувати `i` у цій позиції з `const`, оскільки увесь сенс такої змінної в цій позиції **бути використаним для підрахунку ітерацій**. Просто використовуйте іншу форму циклу, як цикл `while`, або візьміть `let`!

## Неініціалізовані змінні (змінні, розташовані у тимчасовій мертвій зоні)

Коли змінна оголошується через `var`, вона "піднімається" на самий верх своєї області видимості. Але також вона автоматично ініціалізується значенням `undefined`, так що змінну можна використовувати у всій області видимості.

Однак декларації з `let` і `const` поводяться по-іншому.

Розглянемо приклад:

```js
console.log(studentName);
// ReferenceError

let studentName = "Suzy";
```

Результатом запуску цієї програми є те, що перший рядок викличе `ReferenceError`. Залежно від середовища JS, повідомлення про помилку може містити щось на зразок: "Не вдається отримати доступ до studentName перед ініціалізацією."

| ПРИМІТКА: |
| :--- |
| Раніше повідомлення про помилку, як видно з прикладу, було набагато більш розмитим або навіть оманливим. На щастя, кілька з нас у спільноті успішно змогли пролобіювати дозвіл рушіям JS покращити це повідомлення про помилку, щоб воно точніше повідомляло, що не так! |

Це повідомлення про помилку досить ясно вказує на те, що саме не так: `studentName` існує в рядку 1, але воно не було ініціалізоване, тому його ще не можна використовувати. Спробуємо так:

```js
studentName = "Suzy";   // спробуємо ініціалізувати studentName!
// ReferenceError

console.log(studentName);

let studentName;
```

На жаль, ми все ще бачимо `ReferenceError`, але тепер помилка у першому рядку, де ми намагаємося призначити (тобто, ініціалізувати!) цю так звану "неініціалізовану" змінну `studentName`. Та що ж таке?

Справжнє питання полягає в тому, як ініціалізувати неініціалізовану змінну? Для `let` або `const` **єдиний спосіб** ініціалізації – це призначення, поєднане з оголошенням. Саме по собі призначення недостатнє! Розглянемо код:

```js
let studentName = "Suzy";
console.log(studentName);   // Suzy
```

Ми ініціалізуємо `studentName` (у даному випадку значенням "Suzy" замість `undefined`) за допомогою форми оголошення `let`, яка поєднана з присвоєнням.

Можливий інший підхід:

```js
// ..

let studentName;
// або:
// let studentName = undefined;

// ..

studentName = "Suzy";

console.log(studentName);
// Suzy
```


| ПРИМІТКА: |
| :--- |
| А це цікаво! Нагадаємо, що раніше ми говорили, що `var studentName;` це *не те саме*, що `var studentName = undefined;`, але тут вони з `let` поводяться однаково. Різниця зводиться до того, що `var studentName` автоматично ініціалізується у верхній частині області видимості, а `let studentName` ні. |

Згадайте, що ми вже кілька разів стверджували, що *Компілятор* видаляє будь-яких декларатори `var`/`let`/ `const`, замінюючи їх інструкціями у верхній частині кожної області видимості для реєстрації відповідних ідентифікаторів.

Отже, якщо ми проаналізуємо, що тут відбувається, то побачимо нюанс:  *Компілятор* також додає інструкцію в середині програми, в точці, де оголошена змінна `studentName`, для обробки автоматичної ініціалізації. Ми не можемо використовувати змінну в будь-який момент до цієї ініціалізації. Те ж саме стосується як `const`, так і `let`.

Термін, введений TC39 для позначення цього *періоду часу* від входу в область видимості до місця, де відбувається автоматична ініціалізація змінної – "тимчасова мертва зона" (Temporal Dead Zone, TDZ).

TDZ - це проміжок часу, де змінна існує, але все ще неініціалізована, і тому не може бути доступна жодним способом. Тільки виконання інструкцій, залишених *Компілятором* у точці вихідної декларації, може виконати таку ініціалізацію. Після цього TDZ закінчується, і змінну можна використовувати у решті області видимості.

У `var` також суворо кажучі є TDZ, але вона нульової довжини і, отже, непомітна для наших програм! Лише `let` і `const` мають видиму TDZ.

До речі, слово "тимчасова" у назві "тимчасова мертва зона", тобто, TDZ, справді стосується *часу*, а не *місця розташування в коді*. Розглянемо приклад:

```js
askQuestion();
// ReferenceError

let studentName = "Suzy";

function askQuestion() {
    console.log(`${ studentName }, do you know?`);
}
```

Навіть попри те, що `console.log(..)`, який посилається на `studentName`, розташований у коді *після* оголошення `let studentName`, з точки зору часу виклик функції `askQuestion()` відбувається *до того, як* зустрічається оператор `let`, поки `studentName` все ще у TDZ! Звідси і помилка.

Існує поширена помилкова думка, що TDZ означаєЮ щр `let` та `const` не піднімаються. Це неточне або принаймні трохи оманливе твердження. Вони точно піднімаються.

Фактична різниця полягає в тому, що декларації з `let` або `const` не ініціалізуються автоматично на початку області видимості, як це відбувається з `var`. Тоді питання  у тому, чи є автоініціалізація *частиною* підняття, чи ні? Я думаю, що автоматична реєстрація змінної у верхній частині області видимості (тобто те, що я називаю "підняттям") та автоматична ініціалізація у верхній частині області видимості (значенням  `undefined`) - це різні операції, і їх не слід поєднувати під єдиним терміном "підняття".

Ми вже бачили, що `let` та `const` не ініціалізуються автоматично на початку області видимості. Але слід довести, що `let` і` const` *насправді підіймаються* (автоматично реєструються на початку своєї області видимості), з люб'язною допомогою нашого друга перекриттям (див. розділ "Shadowing" в главі 3):

```js
var studentName = "Kyle";

{
    console.log(studentName);
    // ???

    // ..

    let studentName = "Suzy";

    console.log(studentName);
    // Suzy
}
```

Що станеться з першою інструкцією `console.log(..)`? Якщо `let studentName` не підіймається на верх області видимості, тоді перший `console.log(..) `*має* вивести `"Kyle"`, чи не так? На той момент, здавалося б, існує лише зовнішня змінна `studentName`, тому  `console.log(..)` має мати до неї доступ та вивести в консоль.

Але натомість перший `console.log(..)` видає помилку TDZ, оскільки насправді `studentName` внутрішньої області видимості **було** підняте (автоматично зареєстроване у верхній частині області видимості). Що **ще** не сталося (ще!), так це автоматична ініціалізація цього внутрішнього `studentName`; на той момент це все ще неініціалізована змінна, отже, порушення TDZ!

Отже, підсумовуючи, помилки TDZ трапляються, оскільки декларації `let` чи `const` *піднімають* свої декларації на початок своїх областей видимості, але на відміну від `var`, вони відкладають автоматичну ініціалізацію своїх змінних до моменту в коді, де з’явилася оригінальна декларація. Це вікно часу (підказка: тимчасове), незалежно від його довжини, є TDZ.

Як можна уникнути помилок TDZ?

Моя порада така: завжди розміщуйте свої декларації `let` та `const` зверху області видимості. Зменшіть вікно TDZ до нульової (або близько до нульової) довжини, тоді і питання не буде.

Але чому взагалі існує TDZ? Чому комітет TC39 не вирішив, що `let` та `const` автоматично ініціалізується так, як це робить `var`? Наберіться терпіння, ми повернемось до питання, *чому* TDZ існує, у Додатку А.

## Нарешті ініціалізовано

Робота зі змінними має набагато більше нюансів, ніж здається на перший погляд. *Підняття*, *(пере) декларація* та *TDZ* є загальновідомим джерелами заплутаності для розробників, особливо тих, хто до JS працював з іншими мовами. Перш ніж рухатися далі, переконайтеся, що ваша ментальна модель відносно областей видимості та змінних у JS цілком достатньо стабільна.

Зазвичай підняття називається явним механізмом рушія JS, але насправді це більше метафора для опису різних способів обробки оголошень змінних під час компіляції. Але навіть як метафора підняття пропонує корисну структуру для роздумів про життєвий цикл змінної - коли вона створюється, коли вона доступна для використання, коли вона зникає.

Оголошення та повторне оголошення змінних, як правило, викликають плутанину, коли їх розглядають як операції часу виконання. Але якщо думати про них як про операції часу компіляції, химерності та *тіньові аспекти* зменшуються.

Помилка TDZ (тимчасової мертвої зони) є дивною і неприємною при зустрічі. На щастя, TDZ є відносно просто уникати, якщо ви завжди обережно розміщуєте декларації `let` / `const` зверху будь-якої області видимості.

Коли ви успішно розберетеся у цих хитрощах змінних та областей видимотсі, переходьте до наступного розділу, де будуть викладені фактори, що керують нашими рішеннями щодо розміщення наших декларацій у різних областях видимості, особливо у вкладених блоках.
