# You Don't Know JS Yet: Області видимості та замикання - Друге видання

# Розділ 2: Ілюстрація лексичної області видимості

У розділі 1, ми розглянули як область видимості була визначена під час компіляції, модель "лексичної області видимості". Період "лексичності" відбувається на першому етапі компіляції(токенізація/лексинг).

Щоб _зрозуміти_ наші програми, важливо мати чітке уявлення того, як працює область видимості. Якщо ми покладатимемось тільки на здогадки та інтуїцію, ми можемо випадково отримати правильні відповіді, але зрештою так не відбувається. Це не наш рецепт успіху.

Згадаємо свій шкільний математичний клас: недостатньо отримати правильну відповідь без наявності ходу власних думок! У нашому випадку потрібно будувати точні та корисні розумові моделі,щоб рухатись вперед.

Цей розділ проілюструє _області видимості_ кількома метафорами. Головна мета:_обдумати_ як обробляється ваша програма за допомогою рушія JS таким чином, щоб ближче відповідати тому, як насправді працює рушій JS.

## Кульки, і Відра, і Оболонки ... Ой, лишенько!

Однією з метафор, яку я визнав ефективною для розуміння області видимості є сортування кольорових кульок у відра відповідного кольору.

Уявіть, що ви натрапили на купу кульок і помічаєте, що всі кульки пофарбовані в червоний, синій або зелений кольори. Давайте відсортуємо всі кульки відповідно до кольорів: червоні у червоне відро, зелені у зелене відро, а сині у синє відро. Після сортування, коли вам знадобиться зелена кулька, ви знатимете про зелене відно й звідки потрібно дістати її.

У цій метафорі кульки - це змінні у нашій програмі. Відра - це області видимості (функції та блоки), які ми концептуально призначаємо окремими кольорами для подальших кроків. Таким чином, колір кожної кульки визначається тим, в якій _кольоровій_ області видимості ми знаходимо кульку.

Давайте підсумуємо приклад запущеної програми з розділу 1 кольоровими позначками області видимості:

```js
// зовнішня/глобальна область видимості: ЧЕРВОНИЙ

var students = [
  { id: 14, name: "Кайл" },
  { id: 73, name: "Сюзі" },
  { id: 112, name: "Френк" },
  { id: 6, name: "Сара" },
];

function getStudentName(studentID) {
  // область видимості функції: СИНІЙ

  for (let student of students) {
    // видимості функції циклу: ЗЕЛЕНИЙ

    if (student.id == studentID) {
      return student.name;
    }
  }
}

var nextStudent = getStudentName(73);
console.log(nextStudent); // Сюзі
```

Ми позначили три кольори області видимості помітками: ЧЕРВОНИЙ (крайня глобальна область видимості), СИНіЙ (область функції `getStudentName (..)`) та ЗЕЛЕНИЙ (область дії всередині циклу `for`). Але всеодно, під час перегляду коду, може бути складно розпізнати межі кожнонр відра області видимості.

Рисунок 2 допоможе візуалізувати межі областей видимості, намалювавши кольорові оболонки (вони ж відра) навколо кожного:

<figure>
    <img src="images/fig2.png" width="500" alt="Colored Scope Bubbles" align="center">
    <figcaption><em>Fig. 2: Colored Scope Bubbles</em></figcaption>
</figure>

1. **Оболонка 1** (ЧЕРВОНИЙ) містить глобальну область видимості, яка містить три ідентифікатори / змінні: `students` (рядок 1),` getStudentName` (рядок 8) та `nextStudent` (рядок 16).

2. **Оболонка 2** (СИНІЙ) містить область видимості функції `getStudentName (..)` (рядок 8), яка містить лише один ідентифікатор/змінну: параметр `studentID` (рядок 8).

3. **Оболонка 3** (ЗЕЛЕНИЙ) містить область видимості циклу `for` (рядок 9), який містить лише один ідентифікатор / змінну: `student` (рядок 9).

| Примітка:                                                                                                                                                                                                    |
| :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Technically, the parameter `studentID` is not exactly in the BLUE(2) scope. We'll unwind that confusion in "Implied Scopes" in Appendix A. For now, it's close enough to label `studentID` a BLUE(2) marble. |

Теоретично параметр `studentID` не зовсім в СИНІЙ (2) області видимості. Ми розберемо це непорозуміння в "Припущеннях області видимості" у Додатку А. Наразі припустимо позначити `studentID 'СИНЬОЮ (2) кулькою.

Оболонки області видимості визначаються під час компіляції та залежать від того, де записані функції/блоки області видимості, вкладеності один в одного, тощо. Тобто кожна дочірня оболонка області видимості міститься в оболонці батьківської області видимості. Варто зауважити,що область видимості ніколи не є частково у двох різних зовнішніх областях видимості.

Кожна кулька (змінна/ідентифікатор) забарвлюється залежно від того, в якій оболонці (відрі) вона оголошена, а не за кольором області видимості, з якої можна отримати до неї доступ (наприклад, `students` у рядку 9 та` studentID` у рядку 10).

| Примітка:                                                                                                                                                                                                                                                                                                                                      |
| :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Remember we asserted in Chapter 1 that `id`, `name`, and `log` are all properties, not variables; in other words, they're not marbles in buckets, so they don't get colored based on any the rules we're discussing in this book. To understand how such property accesses are handled, see the third book in the series, _Objects & Classes_. |

| Згадаймо, як в главі 1 ми стверджували, що "id", "name" і "log" - це все властивості, а не змінні; іншими словами, це не кульки у відрах, тому вони не забарвлюються відповідно до тих правил, які ми обговорюємо в цій книзі. Щоб зрозуміти, як обробляються такі властивості, дивіться у третій книзі серії _Objects & Classes_. |

Коли рушій JS обробляє програму (під час компіляції) і знаходить оголошення для змінної, він по суті запитує: "Якого _кольору_ область видимості (оболонка чи відро), у якій я зараз перебуваю?" Змінна позначається того самого _кольору_, врахувавши, що вона належить цьому відру/оболонці.

ЗЕЛЕНЕ (3) відро вкладене всередину СИНЬОГО (2) відра, а також СИНЄ (2) відро повністю вкладене всередину ЧЕРВОНОГО (1) відра. Області видимості можуть бути вкладенні всередину один одного, як показано, на будь-яку глибину вкладеності, наскільки це потрібно вашій програмі.

Посилання (не-оголошені) на змінні/ідентифікатори дозволяються, якщо є відповідне оголошення або в поточній області видимості, або в будь-якій області видимості вище/поза поточною областю видимості, але не з оголошеними з нижчих/вкладених областей видимості.

Вираз у ЧЕРВОНОМУ (1) відрі має доступ лише до ЧЕРВОНИХ (1) кульок, **не** до СИНІХ (2) чи ЗЕЛЕНИХ (3). Вираз у СИНЬОМУ (2) відрі може посилатися як на СИНІ (2) так і на ЧЕРВОНІ (1) кульки,але **не** до ЗЕЛЕНИХ (3). А вираз у ЗЕЛЕНОМУ (3) відрі має доступ до ЧЕРВОНИХ (1), СИНІХ (2) та ЗЕЛЕНИХ (3) кульок.

Ми можемо представити процес визначення цих не оголошених кольорих кульок, під час роботи пошуком. Оскільки посилання на змінну `students` в інструкції циклу` for` у рядку 9 не є оголошеним, воно не має кольору. Тож ми запитуємо поточне СИНЄ (2) відро, чи є в ньому кулька, що відповідає цій назві. Оскільки вона не відповідає, пошук продовжується із наступним зовнішнім/що містить область видимості: ЧЕРВОНИЙ (1).ЧЕРВОНЕ відро (1) має кульку із назвою `students`, тому посилання на змінну `students` із інструкції циклу визначається як ЧЕРВОНА (1) кулька.

Інструкція `if (student.id == studentID)` у рядку 10 аналогічно має доступ до ЗЕЛЕНОЇ (3) кульки з ім'ям `student` та СИНЬОЇ (2) кульки `studentID`.

| Примітка:                                                                                                                                                                                                                                                                                                                                                                                                               |
| :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| The JS engine doesn't generally determine these marble colors during runtime; the "lookup" here is a rhetorical device to help you understand the concepts. During compilation, most or all variable references will match already-known scope buckets, so their color is already determined, and stored with each marble reference to avoid unnecessary lookups as the program runs. More on this nuance in Chapter 3. |

| Рушій JS зазвичай не визначає кольору кульок під час роботи; "пошук" - це риторичний засіб, який допомагає усвідомити концепцію. Під час компіляції більшість або всі посилання на змінні уже відомі областям видимості,тому мають відповідний колір та зберігають відповідене посилання кульки. Це робиться для того щоб уникнути зайвих пошуків під час роботи програми. Більш детальніше про це описується у Розділі 3. |

Підведемо підсумки з кульками,відрами (та оболонками!):

- Змінні,які оголошені в конкретних областях видимості, можна сприймати як кольорові кульки з відповідних кольорам відрів.

- Будь-яке посилання на змінну, яке з’являється в оголошеній області видиості, або з’являється у будь-якій більш глибоко вкладеній області видимості, буде помічено кулькою того самого кольору, якщо тільки проміжна область видимості не заміщує оголошену змінну; див. "Заміщенням (shadowing)" у главі 3.

- Під час компіляції відбувається визначення кольорових відер та кульок, які знаходяться у перших. Ця інформація використовується для "пошуку" змінних (колір кульок) під час виконання коду.

## Розмова між друзями

Іншою корисною метафорою процесу аналізу змінних та області видимості, з якої вони походять, є уявлення різних розмов, що відбуваються всередині рушія під час обробки та виконання коду. Ми можемо «підслухати» ці розмови, щоб отримати краще розуміння основ роботи області видимості.

Давайте зараз познайомимось із членами рушія JS, які будуть вести бесіди під час обробки нашої програми:

- _Рушій_: відповідає за компіляцію від початку до кінця та виконання нашої JavaScript програми.

- _Компілятор_: один із друзів _Рушія_; виконує всю брудну роботу аналізу та генерації коду (див. попередній розділ).

- _Менеджер області видимості_: ще один друг _Рушія_; збирає та підтримує список пошуку всіх оголошених змінних/ідентифікаторів та забезпечує набір правил щодо того, коли вони доступні під час виконунання коду.

Для _повного зрозуміння_, як працює JavaScript, вам слід почати _мислити_, як _Рушій_ (та його друзі),відповідно задавати запитання, як вони, та відповідати на їхні запитання таким же чином.

Щоб дослідити ці розмови, знову згадайте наш приклад запущеної програми:

```js
var students = [
  { id: 14, name: "Кайл" },
  { id: 73, name: "Сюзі" },
  { id: 112, name: "Френк" },
  { id: 6, name: "Сара" },
];

function getStudentName(studentID) {
  for (let student of students) {
    if (student.id == studentID) {
      return student.name;
    }
  }
}

var nextStudent = getStudentName(73);

console.log(nextStudent);
// Сюзі
```

Давайте розберемо, як JS буде обробляти цю програму, зокрема, почавши з першого твердження. Масив та його вміст - це лише основні літерали значення JS (отже, на них не впливають будь-які проблеми, пов’язані з областю видимості), тому наша увага тут буде зосереджена на декларації `var students = [..]` та частинах присвоювання-ініціалізації.

Зазвичай ми думаємо про це як про одне твердження, але це не так як бачить наш друг _Рушій_. Насправді JS розглядає їх як дві різні операції, одну з яких _Компілятор_ обробляє під час компіляції, у той же час іншу - _Рушій_ оброблює під час виконання.

Перше, що _Компілятор_ зробить з цією програмою, - виконає лексинг, щоб розбити її на токени, які пізніше він розпарсить їх на дерево (АСД).

Як тільки _Компілятор_ перейде до генерації коду, слід розглянути більше деталей, оскільни не все так очевидно. Розумним припущенням буде те, що _Компілятор_ створить код для першого твердження, таке як: "Виділіть пам'ять для змінної, позначте її як `студент`, а потім вставте посилання у масиві до цієї змінної." Але це ще не вся історія.

Такі наступні дії _Компілятор_ буде виконувати для обробки цього твердження:

1. Зустрівши `var students`, _Компілятор_ попросить _Менеджера області видимості_ перевірити, чи вже існує змінна з назвою` students` для цього конкретного сегменту області видимості. Якщо так, _Компілятор_ проігнорує цю декларацію і піде далі. У іншому випадку _Компілятор_ видасть код, який (під час виконання) запросить у _Менеджера області видимості_ створити нову змінну під назвою `students` у цьому сегменті області видимості.

1. Потім _Компілятор_ створює код для _Рушія_ для подальшого виконання та обробки `students = []`. Спершу перед запуском код _Рушія_ запитає _Менеджера області видимості_, чи є в поточному сегменті області видимості доступна змінна під назвою `students`. Якщо ні, _Рушій_ продовжує шукати в іншому місці (див. "Вкладена область видимості" нижче). Після того, як _Рушій_ знаходить змінну, він присвоює їй посилання на масив `[..]`.

У розмовній формі перший етап компіляції для програми може відбутися між _Компілятор_ та _Менеджером області видимості_ наступним чином:

> **_Компілятор_**: Агов, _Менеджер області видимості_ (глобального сегменту), я знайшов зовнішню декларацію для ідентифікатора під назвою `students`, коли-небудь чув про це?

> **_(Глобальний) Менеджер області видимості_**: Ні, не приходилось, тому я створив його для тебе.

> **_Компілятор_**: Агов, _Менеджер області видимості_, я знайшов зовнішню декларацію для ідентифікатора під назвою `getStudentName`, коли-небудь чув про це?

> **_(Глобальний) Менеджер області видимості_**: Ні, але щойно створив його для тебе.

> **_Компілятор_**: Агов, _Менеджер області видимості_, `getStudentName` вказує на функцію, тому нам потрібен новий сегмент області видимості.

> **_(Функціональний) Менеджер області видимості_** Зрозумів, ось сегмент області видимості.

> **_Компілятор_**: Агов, _Менеджер області видимості_ (функції), я знайшов зовнішню декларацію параметра для `studentID`, коли-небудь чув про це?

> **_(Функціональний) Менеджер області видимості_**: Ні, але він вже створений у цій області видимості.

> **_Компілятор_**: Агов, _Менеджер області видимості_ (функції), я знайшов цикл `for`, який потребуватиме власного сегмента області видимості.

> ...

Розмова - це обмін запитаннями та відповідями, де **Компілятор** запитує поточного _Менеджера області видимості_ чи вже зустрічалася декларація ідентифікатора. Якщо "ні", _Менеджер області видимості_ створює цю змінну у цій області видимості. Якщо відповідь "так", то її фактично пропускають, оскільки _Менеджеру області видимості_ більше нічого робити.

_Compiler_ also signals when it runs across functions or block scopes, so that a new scope bucket and _Scope Manager_ can be instantiated.

_Компілятор_ також повідомляє, коли він запускається через функції або блоки області видимості, тож можна створити нові сегмент області видимості та _Менеджера області видимості_.

Пізніше, коли справа стосується виконання програми, розмова відбудеться між _Рушієм_ та _Менеджером області видимості_, і може розігратися так:

> **_Рушій_**: Агов, _Менеджер області видимості_ (глобального сегменту), перед тим, як ми розпочнемо, чи можеш ти знайти ідентифікатор `getStudentName`, щоб я міг призначити йому цю функцію?

> **_(Глобальний) Менеджер області видимості_**: Так, ось така змінна.

> **_Рушій_**: Агов, _Менеджер області видимості_, я знайшов _цільове_ посилання для `students`, коли-небудь чув про це?

> **_(Глобальний) Менеджер області видимості_**: Так, це було формально оголошено для цієї області видимості, ось воно.

> **_Рушій_**: Дякую, я ініціюю `students` до `undefined`, тому він готовий до використання.

> Гей, _Менеджер області видимості_ (глобальний), я знайшов _цільове_ посилання для `nextStudent`, коли-небудь чув про це?

> **_(Глобальний) Менеджер області видимості_**: Так, це було формально оголошено для цього обсягу, тому ось воно.

> **_Рушій_**: Дякую, я ініціалізую `nextStudent` до` undefined`, тому він готовий до використання.

> Гей, **_(Глобальний) Менеджер області видимості_**, я знайшов посилання на _source_ для `getStudentName`, коли-небудь чув про це?

> **_(Глобальний) Менеджер області видимості_**: Так, це було формально оголошено для цієї області видимості. Ось воно.

> **_Рушій_**: Чудово, значення в `getStudentName` є функцією, тому я збираюся її виконати.

> **_Рушій_**: Агов, _Менеджер області видимості_, тепер нам потрібно створити функціональну область видимості.

> ...

Ця розмова є черговим обміном запитаннями та відповідями, де _Рушій_ спершу запрошує поточного _Менеджера області видимості_ знайти піднятий ідентифікатор `getStudentName`, щоб пов'язати з ним функцію. Потім _Рушій_ запитує _Менеджера області видимості_ про _цільове_ посилання для `students` тощо.

Переглянемо та підсумуємо, як обробляється твердження типу `var students = [..]`, у два окремі кроки:

1. _Компілятор_ встановлює оголошення змінної області видимості (оскільки вона раніше не була оголошена в поточній області видимості).

1. Поки _Рушій_ виконується, щоб обробити частину присвоєного оператора, _Рушій_ просить _Менеджера області видимості_ для пошуку змінної, він ініціалізує її до `undefined`, щоб вона була готова до використання, а потім присвоює їй значення масиву.

## Вкладена функція

Коли настає час виконати функцію `getStudentName ()`, _Рушій_ запитує _Менеджера області видимості_ екземпляр області видимості цієї функції, а пізніше він продовжить пошук параметра (`studentID`), щоб присвоїти значення аргументу` 73` , і так далі.

Область видимості функції для `getStudentName (..)` вкладена всередину глобальної області видимості. Область видимості блоку циклу `for` аналогічна вкладеній всередину області видимості цієї функції. Області видимості можуть бути лексично вкладені в будь-яку довільну глибину, як це визначає сама програма.

Кожного разу, коли виконується область видимості, кожна з них отримує свій власний екземпляр _Менеджера області видимості_ (один або кілька разів). Кожна область видимості автоматично реєструє всі свої ідентифікатори на початку виконання свого сегменту області видимості (це називається "підняття змінної"; див. Розділ 5).

На початку області видимості, якщо будь-який ідентифікатор походить з оголошення `function`, ця змінна автоматично ініціалізується до пов'язаного з нею посиланням на функцію. І якщо будь-який ідентифікатор має походження від декларації `var` (на відміну від` let` / `const`), ця змінна автоматично ініціалізується до `undefined`, щоб її можна було використовувати; в іншому випадку змінна залишається неініціалізованою (вона перебуває у своїй Тимчасово мертвій зоні "ТМЗ"("TDZ"), див. розділ 5) і не може бути використана, поки не буде повністю виконано її декларування та ініціалізація.

У твердженні `for (let student of students) {`statement, `students` - це _першо_ посилання, яке потрібно шукати. Але як буде оброблятися цей пошук, якщо область видимості функції не знайде такого ідентифікатора?

Щоб пояснити, давайте уявимо розмову, яка розігрується ось так:

> **_Рушій_**: Агов, _Менеджер області видимості_(функції), у мене є _першо_ посилання для `students`, коли-небудь чув про це?

> **_(Функціональний) Менеджер області видимості_**: Ні, ніколи про це не чув. Спробуй наступну зовнішню область видимості.

> **_Рушій_**: Агов, _Менеджер області видимості_ (глобальний), у мене є _першо_ посилання для `students`, коли-небудь чув про це?

> **_(Глобальний) Менеджер області видимості_**: Так, це було формально оголошено, ось воно.

> ...

Одним з ключових аспектів лексичної області видимості є те, що кожного разу, коли посилання на ідентифікатор не може бути знайдене в поточній області видимості, проводиться консультація щодо наступного зовнішнього обсягу видимості; цей процес повторюється до тих пір, поки не буде знайдена відповідь або не буде більше областей видимості для консультацій.

### Хибність пошуку

Коли _Рушій_ вичерпує всі _лексично доступні_ області видимості (рухаючись назовні) і все ще не зможе завершити пошук ідентифікатора, тоді виникає стан помилки. Однак, залежно від режиму програми (строгий режим чи ні) та ролі змінної (тобто _цільова_ (подія) проти _початковий_; див. Розділ 1), ця умова помилки буде оброблятися по-різному.

#### Невизначений безлад

Якщо змінна є _початковою_, невирішений пошук ідентифікатора вважається незадекларованою (невідомою, відсутнею) змінною, що завжди призводить до "ReferenceError". Крім того, якщо змінна є _цільовою_, а код на той момент працює в строгому режимі, змінна вважається незадекларованою і аналогічно видає `ReferenceError`.

Повідомлення про помилку для незадекларованої умови змінної у більшості середовищ JS буде виглядати так: "Помилка посилання: XYZ не визначено". Фраза "не визначено" здається майже ідентичною слову "невизначений", що стосується англійської мови. Але ці двоє дуже різні в JS, і це повідомлення про помилку, на жаль, створює стійке непорозуміння.

"Не визначено" насправді означає "не оголошено" - або, швидше, "незадекларовано", як у змінній, яка не має відповідного (формального) оголошення в жодній _лексично доступній_ області видимості. На відміну від цього, "невизначений" насправді означає, що змінна була знайдена (оголошена), але в іншому випадку змінна не має іншого значення на даний момент, тому за замовчуванням вона має значення `невизначений`.

Щоб створити ще більше непорозуміння, оператор JS `typeof` повертає рядок `undefined` для посилань на змінні в будь-якому стані:

```js
var studentName;
typeof studentName; // "undefined"

typeof doesntExist; // "undefined"
```

Ці два посилання на змінні знаходяться в дуже різних умовах, але JS впевнено робить ці води каламутними. Термінологічний безлад завжди призводить до плутани, і є страшенно незручним для використання. На жаль, розробникам JS потрібно просто більше приділяти уваги, щоб не перемішувати _з якими_ "невизначеними" вони мають справу!

#### Глобальне... Що!?

Якщо змінна є _цільовою_, а строгий режим не діє, починається заплутана та дивовижна застаріла поведінка. Проблемним наслідком стане те, що _Менеджер області видимості_ глобальної області видимості просто створить **випадкову глобальну змінну** для виконання цього цільового призначення !

Розглянемо:

```js
function getStudentName() {
  // assignment to an undeclared variable  присвоєння незадекларованій змінній :(
  nextStudent = "Сюзі";
}

getStudentName();

console.log(nextStudent);
// "Сюзі" -- oops, an accidental-global variable! ой, випадково-глобальна змінна!
```

Ось як відбудеться ця _розмова_:

> **_Рушій_**: Агов, _Менеджер області видимості_ (для функції), у мене є _цільове_ посилання для `nextStudent`, коли-небудь чув про це?

> **_(Функціональний) Менеджер області видимості_**: Ні, ніколи про це не чув. Спробуй наступну зовнішню область видимості.

> **_Рушій_**: Агов, _Менеджер області видимості_ (для глобальної), у мене є _цільове_ посилання для `nextStudent`, коли-небудь чув про це?

> **_(Глобальний) завідувач області видимості_**: Ні, але оскільки ми перебуваємо в нестрогому режимі, я зробив тобі послугу та просто створив для тебе глобальну змінну, ось вона!

Гидота.

Такий випалок (майже напевно призведе до помилок врешті-решт) є чудовим прикладом корисного захисту, який пропонує строгий режим, і чому _не_ використання строгого режиму є настільки поганою ідеєю. У суворому режимі **_Глобальний Менеджер області видимості_** натомість відповів би:

> **_(Глобальний) завідувач області видимості_**: Ні, ніколи про це не чув. Вибачай, але я мушу видати `ReferenceError`.

Призначення ніколи-не-оголошеної змінної _є_ помилкою, тому правильно, що ми отримаємо тут `ReferenceError`.

Ніколи не покладайтесь на випадкові глобальні змінні. Завжди використовуйте строгий режим і завжди формально заявляйте про свої змінні. Тоді ви отримаєте корисну `ReferenceError`, якщо коли-небудь помилково спробуєте призначити не оголошену змінну.

### Беремо за основи метафори

Для візуалізації вкладеної роздільної здатності я віддаю перевагу ще одній метафорі - офісна будівля, як на малюнку 3:

<figure>
    <img src="images/fig3.png" width="250" alt="Scope &quot;Building&quot;" align="center">
    <figcaption><em>Fig. 3: Scope "Building"</em></figcaption>
    <br><br>
</figure>

Будівля представляє вкладену колекцію областей видимості нашої програми. Перший поверх будівлі відповідає поточному об'єкту. Верхній рівень будівлі - це глобальна область видимості.

Ви вирішуєте посилання на _цільову_ або _початкову_ змінну , спершу переглянувши поточний поверх, і якщо не знайдете її, піднімаєтесь ліфтом на наступний поверх (тобто на зовнішню область видимості), заглянувши туди, потім на наступний, і так далі . Дійшовши до останнього поверху (глобальної області видимості), ви або знайдете те, що шукаєте, або ні. Але зупинятися доводеться незалежно.

## Продовжуємо розмову

До цього моменту у вас повинно бути набагато більше розуміння ідеї: що таке область вилимості, та як рушій JS визначає та використовує його з вашого коду.

Перш ніж _продовжувати_, гляньте на код в одному зі своїх проектів і пройдіться цими розмовами. Серйозно, проговоріть це вголос. Покличте друга та попрактикуйте з ними кожну роль. Якщо хтось із вас виявився розгубленим або невпевненим, витратьте більше часу на засвоєння цього матеріалу.

Переходячи (вгору) до наступного (зовнішнього) розділу, ми дослідимо, як лексичні області видимості програм пов’язані одним ланцюгом.
