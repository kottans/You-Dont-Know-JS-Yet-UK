# Серія "Ти поки що не знаєш JS". Області видимості та замикання - Друге видання
# Глава 6: Обмеження доступу до області видимості

Поки що ми зосереджувались на поясненні механіки роботи областей видимості та змінних. Тепер, коли цей фундамент міцно встановлений, наша увага підіймається на вищий рівень мислення: рішення та патерни, які ми застосовуємо у всій програмі.

Для початку ми розглянемо, як і чому ми повинні використовувати різні рівні областей видимості (функції та блоки) для організації змінних нашої програми, зокрема для зменшення надмірного вільного доступу.

## Мінімізація доступу

Те, що функції визначають власні області видимості, має сенс. Але з якої причини блоки також створюються власні області видимості?

Інженерія програмного забезпечення формулює фундаментальну дисципліну, яка зазвичай застосовується до забезпечення програмного забезпечення, і називається "Принцип найменших привілеїв" (POLP). [^POLP] І варіант цього принципу, який має відношення до нашої поточної дискусії, зазвичай позначається як "Найменший вплив"("Least Exposure", POLE).

POLP виражає підхід до архітектури програмного забезпечення, що виходить з позиції захисту: компоненти системи повинні бути спроєктовані так, щоб вони функціонували з найменшими привілеями, найменшим доступом та мінімальним впливом. Якщо кожен фрагмент пов'язаний з мінімально необхідними можливостями, загальна система є сильнішою з точки зору безпеки, оскільки порушення безпеки або відмова однієї частини має мінімізований вплив на решту системи.

Якщо POLP зосереджується на дизайні компонентів на системному рівні, варіант POLE * Exposure * фокусується на нижчому рівні; ми застосуємо це до того, як сфери взаємодіють між собою.

До чого ми хочемо мінімізувати доступ, дотримуючись POLE? Просто: до змінних, зареєстровані в кожній області видимості.

Подумайте про це так: чому б вам просто не розмістити всі змінні вашої програми в глобальній області видимості? Можливо, ви одразу вирішите, що це погана ідея, але варто подумати, чому це так. Коли змінні, що використовуються однією частиною програми, через область видимості підпадають під дію іншої частини програми, часто це може створити три основні погрози:

* **Колізія імен**: якщо ви використовуєте спільну та корисну назву змінної чи функції у двох різних частинах програми, але ідентифікатор походить з однієї спільної області видимості (наприклад, глобальної), то виникає колізія імен, і дуже ймовірно призведе до помилок, оскільки одна частина використовує змінну чи функцію так, як інша частина не очікує.

     Наприклад, уявіть, що всі ваші цикли використовують одну глобальну змінну індексу `i`. Тоді трапляється, що один цикл у функції виконується під час ітерації циклу з іншої функції, і тепер спільна змінна `i` отримує несподіване значення.

* **Несподівана поведінка**: якщо ви даєте доступ до змінної або функції, використання яких інакше є *приватним*, частині програми, це дозволяє іншим розробникам використовувати їх у спосіб, який ви не передбачали, що може порушити очікувану поведінку та спричинити помилки.

    Наприклад, якщо ваша частина програми передбачає, що масив містить лише цифри, але чужий код отримує доступ і модифікує масив та додає логічні значення та рядки, ваш код після цього може демонструвати дуже несподівану поведінку.

    Гірше того, викриття *приватних* деталей запрошує тих, хто має зловмисні наміри, спробувати обійти обмеження, які ви наклали, і зробити з вашою частиною програмного забезпечення те, що не можна дозволяти.

* **Ненавмисна залежність**: якщо ви надаєте доступ до змінної чи функції без потреби, це запрошує інших розробників використовувати їх та покладатися на те, що в іншому випадку було б *приватним* знанням. Хоча це не порушує роботи вашої програми сьогодні, воно створює небезпеку для рефакторингу в майбутньому, оскільки тепер ви не можете так легко відрефакторити цю змінну або функцію та бути певним, що не порушите інші частини програмного забезпечення, якими ви не керуєте.

    Наприклад, якщо ваш код покладається на масив чисел, і згодом ви вирішите, що краще використовувати іншу структуру даних замість масиву, тепер ви повинні взяти на себе відповідальність за коригування інших частин програмного забезпечення, на які вплине ця зміна.

Принцип POLE, як застосовується до обсягу області видимості змінної чи функції, по суті, говорить, що за замовчуванням виставляється мінімальний необхідний обсяг, зберігаючи все інше якомога приватнішим. Оголошуйте змінні в якомога менших і глибоко вкладених областях видимості, а не розміщуючи все в глобальній чи навіть зовнішній функційній області.

Якщо ви розробляєте своє програмне забезпечення відповідно, у вас є набагато більше шансів уникнути (або, принаймні, мінімізувати) ці три загрози.

Розглянемо приклад:

```js
function diff(x,y) {
    if (x > y) {
        let tmp = x;
        x = y;
        y = tmp;
    }

    return y - x;
}

diff(3,7);      // 4
diff(7,5);      // 2
```

У цій функції `diff(..)` ми хочемо переконатися, що `y` більше або дорівнює `x`, так що коли ми віднімаємо (`y - x`), результат буде число `0` або більше. Якщо `x` спочатку більше (результат буде від'ємним!), Ми міняємо місцями `x` та `y`, використовуючи змінну `tmp`, щоб результат залишався позитивним.

У цьому простому прикладі, схоже, не має значення, чи `tmp` знаходиться всередині блоку `if`, чи належить знаходиться на рівні функції. Глобальною ця змінна, безумовно, не повинна! Однак, дотримуючись принципу POLE, `tmp` має бути якомога краще прихованою в області видимості. Отже, ми обмежуємо її блоковою областю видимості `if` за `let`.

## Як сховати змінну у звичайній (функційній) області видимості

На цей момент має зрозуміло, чому важливо приховувати наші оголошення змінних та функцій у найнижчій (найбільш глибоко вкладеній) області видимості. Але як це зробити?

Ми вже бачили ключові слова `let` і `const`, які є деклараторами блокового рівня; ми повернемось до них найближчим часом. Але спочатку, як щодо приховування оголошень `var` або `function` в областях видимості? Це можна легко зробити, огорнувши оголошення функційною областю видимості.

Розглянемо приклад, коли функційна область видимості може бути корисною.

Математична операція "факторіал" (позначена як "6!") - це множення певного цілого числа на всі послідовно менші цілі числа до `1`. Насправді ви можете зупинитися вже на `2`, оскільки множення `1` нічого не робить. Іншими словами, "6!" те саме, що "6 * 5!", що те саме, що "6 * 5 * 4!" тощо. Зважаючи на характер розрахунків, маючи факторіал будь-якого цілого числа (наприклад, "4!"), нам не потрібно рахувати його ще раз, оскільки відповідь завжди буде однаковою.

Отже, якщо ви обчислюєте факторіал для `6` з наївним підходом, то пізніше, коли захочете розрахувати факторіал для `7`, ви можете марно перерахувати факторіали всіх цілих чисел від 2 до 6. Якщо ви бажаєте обміняти пам'ять на швидкість, ви можете позбутися цього марного обчислення, кешуючи факторіал кожного цілого числа під час його обчислення:

```js
var cache = {};

function factorial(x) {
    if (x < 2) return 1;
    if (!(x in cache)) {
        cache[x] = x * factorial(x - 1);
    }
    return cache[x];
}

factorial(6);
// 720

cache;
// {
//     "2": 2,
//     "3": 6,
//     "4": 24,
//     "5": 120,
//     "6": 720
// }

factorial(7);
// 5040
```

Ми зберігаємо всі обчислювані факторіали в `cache` так, щоб у кількох викликах `factorial(..)` залишаються попередні обчислення. Але змінна `cache` є цілком очевидно *приватною* деталлю того, як працює `factorial(..)`, а не чимось, що слід виставляти у зовнішній області видимості - особливо якщо йдеться про глобальну область.

| ПРИМІТКА: |
| :--- |
| `factorial(..)` тут рекурсивний - функція сама себе викликає зсередини, - але це лише для стислості коду. Нерекурсивна реалізація дасть той самий аналіз областей видимості щодо змінної `cache`. |

Однак щоб виправити цю проблему надмірної відкритості, недостатньо сховати змінну `cache` всередині `factorial(..)`. Оскільки змінна `cache` має лишатися між викликами функції, вона має знаходитися в області поза цією функцією. То що ми можемо зробити?

Визначте ще одну середню область (між зовнішньою чи глобальною областю видимості та внутрішньою частиною `factorial(..)`) для розміщення `cache`:

```js
// зовнішня або глобальна область видимості

function hideTheCache() {
    // "середня область видимості", де ми ховаємо `cache`
    var cache = {};

    return factorial;

    // **********************

    function factorial(x) {
        // внутрішня область видимості
        if (x < 2) return 1;
        if (!(x in cache)) {
            cache[x] = x * factorial(x - 1);
        }
        return cache[x];
    }
}

var factorial = hideTheCache();

factorial(6);
// 720

factorial(7);
// 5040
```

Функція `hideTheCache()` не має жодної іншої мети, як створити область видимості для `cache`, яка зберігатиметься під час декількох викликів до `factorial(..)`. Але для того, щоб `factorial(..)` мав доступ до `cache`, нам потрібно визначити `factorial(..)` всередині тієї самої області видимості. Потім ми повертаємо посилання на функцію як значення з `hideTheCache()` і зберігаємо його у зовнішній змінній області, також названій `factorial`. Тепер, коли ми називаємо `factorial(..)` (кілька разів!), Його постійний `cache` залишається прихованим, але доступним лише для `factorial(..)`!

Гаразд, але... буде незручно визначати (і називати!) Область функції `hideTheCache(..)` кожного разу, коли виникає така потреба у приховуванні змінної / функції, тим більше, що ми, швидше за все, хочемо уникати колізії імен з цією функцією, надаючи кожному випадку унікальну назву. Тьфу.

| ПРИМІТКА: |
| :--- |
| Показана техніка - кешування обчислюваного виводу функції для оптимізації продуктивності, коли очікуються повторні виклики з тими самими вхідними даними - досить поширена у світі функційного програмування (FP), що може канонічно називатися "мемоізацією"; це кешування ґрунтується на замиканнях (див. розділ 7). Крім того, існують проблеми з використанням пам'яті (розглянуті в розділі "Кілька слів про пам'ять" у Додатку Б). Бібліотеки FP зазвичай пропонують оптимізовану та перевірену утиліту для мемоізації функцій, яка тут замінить `hideTheCache(..)`. Мемоізація виходить за рамки нашого обговорення, але для отримання додаткової інформації дивіться мою книгу *Функційний легкий JavaScript*(Functional-Light JavaScript). |

Замість того, щоб визначати щоразу нову функцію з унікальним ім'ям, коли виникає одна з тих ситуацій, що стосуються лише області видимості приховування змінної, можливо кращим рішенням є використання функційного виразу:

```js
var factorial = (function hideTheCache() {
    var cache = {};

    function factorial(x) {
        if (x < 2) return 1;
        if (!(x in cache)) {
            cache[x] = x * factorial(x - 1);
        }
        return cache[x];
    }

    return factorial;
})();

factorial(6);
// 720

factorial(7);
// 5040
```

Зачекайте! Це все ще використовує функцію для створення області для приховування `cache`, і в цьому випадку функція все ще називається `hideTheCache`, то як це може щось вирішити?

Згадайте з "Функційна область видимості імен" (у розділі 3), що відбувається з ідентифікатором імені з виразу `function`. Оскільки `hideTheCache(..)` визначається як  функційний вираз замість оголошення функцій, його ім'я знаходиться у власній області видимості - по суті, тій самій області, що і `cache`, а не у зовнішній чи глобальній області.

Це означає, що ми можемо присвоювати кожному окремому випадку такого виразу функції однакові імена і ніколи не мати колізій. Проте краще називати кожне входження семантично, виходячи з того, що саме ми намагаємось приховати, і не хвилюватися, що будь-яке вибране нами ім’я співпаде з будь-якою іншою областю видимості функційного виразу.

Насправді ми *могли* просто залишити це ім'я - таким чином, замість цього визначивши "анонімний функційний вираз". Але Додаток А обговорить важливість імен навіть для таких функцій, що існує лише заради створення області видимості.

### Негайний виклик функційного виразу

У попередній рекурсивній програмі для обрахунку факторіалу є ще один важливий нюанс, який легко пропустити: рядок у кінці функційного виразу, що містить`})();`.

Зверніть увагу, що ми оточили весь функційний вираз круглими дужками `(..)`, а потім, наприкінці, ми додали другий набір дужок `()`; це виклик функційного виразу, який ми щойно визначили. Щобільше, у цьому випадку перший набір дужок `(..)` навколо функційного виразу не є суворо необхідним (про це трохи пізніше), але ми все одно додали їх для простоти читання.

Отже, іншими словами, ми визначаємо функційний вираз, який одразу викликається. Цей загальний шаблон має (дуже креативне!) назву: функційний вираз, що викликається негайно (Immediately Invoked Function Expression, IIFE).

IIFE корисний, коли ми хочемо створити область видимості для приховування змінних чи функцій. Оскільки це вираз, його можна використовувати в **будь-якому** місці JS-програми, де може бути вираз. IIFE може бути іменованим, як з `hideTheCache ()`, або (набагато частіше!) нейменованим, тобто анонімним. І він може бути автономним або, як і раніше, частиною іншого оператора - `hideTheCache()` повертає посилання на функцію `factorial()`, яке потім призначається за допомогою оператора `=` змінній `factorial`.

Для порівняння, ось приклад автономного IIFE:

```js
// зовнішня область видимості

(function(){
    // прихована внутрішня область видимості
})();

// зовнішня область видимості продовжується
```

На відміну від `hideTheCache()`, яку ми бачили раніше, де зовнішні дужки `(..)` було зазначено як необов’язковий стилістичний вибір, для автономного IIFE вони **необхідні**; вони розрізняють функцію вираз від інструкції. Однак для послідовності завжди оточуйте IIFE символом `(..)`.

| ПРИМІТКА: |
| :--- |
| Технічно дужки `(..)` не є єдиним синтаксичним способом забезпечити, щоб функція в IIFE оброблялася парсером JS як функційний вираз. Ми розглянемо деякі інші варіанти в Додатку А. |

#### Межі функцій

Пам'ятайте, що використання IIFE для визначення області видимості може мати деякі ненавмисні наслідки, залежно від коду навколо нього. Оскільки IIFE є повноцінною функцією, межі функції змінюють поведінку певних операторів та конструкцій.

Наприклад, оператор `return` у якомусь фрагменті коду змінює своє значення, якщо навколо нього з'являється IIFE, оскільки тепер `return` буде посилатися на функцію IIFE. Функції IIFE, що не є стрілковими, також змінюють прив’язку ключового слова `this` - про це докладніше в книзі *Об'єкти та класи*. І такі оператори, як `break` та `continue`, не працюватимуть через межі функції IIFE для управління зовнішнім циклом або блоком.

Отже, якщо код, який вам потрібно обернути область, містить `return`, `this`, `break`, або `return`, `this`, `break`, IIFE, мабуть, не найкращий підхід. У цьому випадку ви можете спробувати виокремити область видимості за допомогою блоку.

## Виокремлення області видимості за допомогою блоків

До цього моменту ви повинні відчувати себе досить комфортно з перевагами створення областей  видимості для обмеження доступу до ідентифікаторів.

Поки що ми розглядали можливість робити це за допомогою функційної області видимості (тобто, IIFE). Але давайте тепер розглянемо використання оголошень з `let` із вкладеними блоками. Загалом, будь-яка пара фігурних дужок `{ .. }`, яка є інструкцією, буде діяти як блок, проте **не обов'язково** як область видимості.

Блок стає областю дії лише тоді, коли це необхідно, щоб містити його декларації блокової області видимості (тобто `let` або `const`). Розглянемо:

```js
{
    // не обов'язково область видимості (пока що)

    // ..

    // тепер вже зрозуміло, що блок має створити область видимості
    let thisIsNowAScope = true;

    for (let i = 0; i < 5; i++) {
        // це також область видимості, що активується
        // ітерацією
        if (i % 2 == 0) {
            // це просто блок, що не створює область видимості
            console.log(i);
        }
    }
}
// 0 2 4
```

Не всі пари фігурних дужок `{ .. }` створюють блоки (і, отже, можуть створити області видимості):

* Літерали об'єктів використовують фігурні дужки `{ .. }`, щоб розмежувати списки ключ-значення, але такі значення об’єктів є **не** областями видимості.

* `class` використовує фігурні дужки `{ .. }` навколо визначення тіла класу, але це не блок чи область видимості.

* Функції використовують фігурні дужки `{ .. }` навколо свого тіла, але технічно це не блок - це тіло функції, що складається з однієї інструкції. Проте, це функційна область видимості.

* Пара фігурних дужок `{..}` після оператора `switch` (навколо набору інструкцій `case`) не визначає блок / область видимості.

За винятком таких позаблокових прикладів, пара фігурних дужок `{ .. }` може визначити блок, приєднаний до інструкції (наприклад, "якщо" або "для"), або самостійно - див. ..} `фігурні дужки в попередньому фрагменті. Явний блок такого роду - якщо він не має оголошень, він насправді не є сферою дії - не служить жодній оперативній меті, хоча все ще може бути корисним як семантичний сигнал.

Явні автономні блоки `{ .. }` завжди були валідним синтаксисом JS, але оскільки вони не могли створювати область видимості до появи `let` та `const` в ES6, вони досить рідкісні. Однак після ES6 вони починають з'являтись частіше.

У більшості мов, що підтримують блокову область видимості, явна блокова область видимості є надзвичайно поширеним шаблоном для створення вузької області видимості для однієї або кількох змінних. Тож, дотримуючись принципу POLE, ми повинні прийняти цей шаблон та зробити більш поширеною в JS; використовувати (явний) блокову область видимості, щоб звузити вплив ідентифікаторів до мінімально можливого.

Явні блокові області видимості можуть бути корисні навіть усередині іншого блоку (незалежно від того, чи є зовнішній блок областю видимості чи ні).

Наприклад:

```js
if (somethingHappened) {
    // це блок, проте не область видимості

    {
        // це і блок, і явна область видимості
        let msg = somethingHappened.message();
        notifyOthers(msg);
    }

    // ..

    recoverFromSomething();
}
```

У цьому коді пара фігурних дужок `{ .. }`  **всередині** `if` створює ще меншу внутрішню блокову область видимості для `msg`, оскільки ця змінна не потрібна для всього блоку `if`. Більшість розробників просто обмежать `msg` блоковою областю видимості, що створена `if`, і підуть далі. І заради справедливості, коли є лише кілька рядків, які слід брати до уваги, це суворий виклик. Але в міру зростання коду ці проблеми з надмірним доступом стають все більш вираженими.

Тож чи має значення додавання зайвої пари `{ .. }` та додаткового рівня відступу? Я думаю, вам слід слідувати POLE і завжди (в межах розумного!) визначати найменший блок для кожної змінної. Тому я рекомендую використовувати додаткову явну блокову область видимості, як показано.

Згадайте обговорення помилок TDZ із розділу "Неініціалізовані змінні (TDZ)" (Глава 5). Там я запропонував таке: щоб мінімізувати ризик помилок TDZ за допомогою декларацій `let` та `const`, завжди розміщуйте ці декларації на початку відповідної області видимості.

Якщо ви помітили, що розміщуєте декларацію `let` в середині області видимості, спочатку подумайте: "О, ні! Небезпека TDZ!" Якщо ця декларація `let` не потрібна в першій половині цього блоку, вам слід використовувати внутрішню явну блокову область видимості, щоб ще більше звузити доступ до змінної!

Інший приклад з явною блоковою областю видимості:

```js
function getNextMonthStart(dateStr) {
    var nextMonth, year;

    {
        let curMonth;
        [ , year, curMonth ] = dateStr.match(
                /(\d{4})-(\d{2})-\d{2}/
            ) || [];
        nextMonth = (Number(curMonth) % 12) + 1;
    }

    if (nextMonth == 1) {
        year++;
    }

    return `${ year }-${
            String(nextMonth).padStart(2,"0")
        }-01`;
}
getNextMonthStart("2019-12-25");   // 2020-01-01
```

Спершу визначимо області видимості та ідентифікатори, що до них належать:

1. Зовнішня або глобальна область має один ідентифікатор, функцію `getNextMonthStart(..)`.

2. Функційна область видимості `getNextMonthStart(..)` містить три: `dateStr`(параметр функції), `nextMonth` і `year`.

3. Пара фігурних дужок `{ .. }` визначає внутрішню блокову область видимості, що містить єдину змінну: `curMonth`.

То навіщо ставити `curMonth` у явну блокову область видимості, а не лишити разом з `nextMonth` та `year` у функційній області верхнього рівня? Оскільки `curMonth` потрібна лише для перших двох інструкцій; доступ до неї з функційної області видимості не виправданий.

Цей приклад невеликий, тому небезпека надмірного викриття `curMonth` досить обмежена. Але переваги принципу POLE найкраще помітні, коли мінімізація доступу стане вашою звичкою. Якщо ви послідовно дотримуватиметеся цього принципу навіть у незначних випадках, він буде служити вам більше у міру зростання ваших програм.

Розглянемо ще більш вагомий приклад:

```js
function sortNamesByLength(names) {
    var buckets = [];

    for (let firstName of names) {
        if (buckets[firstName.length] == null) {
            buckets[firstName.length] = [];
        }
        buckets[firstName.length].push(firstName);
    }

    // блок для обмеження області видимості
    {
        let sortedNames = [];

        for (let bucket of buckets) {
            if (bucket) {
                // відсортуємо кожне відерце у буквено-цифровому порядку
                bucket.sort();

                // додамо відсортовані імена до
                // списку
                sortedNames = [
                    ...sortedNames,
                    ...bucket
                ];
            }
        }

        return sortedNames;
    }
}

sortNamesByLength([
    "Sally",
    "Suzy",
    "Frank",
    "John",
    "Jennifer",
    "Scott"
]);
// [ "John", "Suzy", "Frank", "Sally",
//   "Scott", "Jennifer" ]
```

Існує шість ідентифікаторів, оголошених у п’яти різних областях видимості. Чи всі ці змінні могли існувати в єдиній зовнішній чи глобальній області видимості? Теоретично могли, оскільки всі вони мають унікальні імена і, отже, не спричинять колізію. Та насправді це була б погана організація коду, і, ймовірно, це призвело б до плутанини та майбутніх помилок.

Ми розподіляємо їх на кожну внутрішню вкладену область видимості, за необхідністю. Кожна змінна визначається в якнайглибшій області видимості, щоб програма могла працювати так, як ми хочемо.

`sortedNames` можна було б визначити в функційній області видимості верхнього рівня, але це потрібно лише для другої половини цієї функції. Щоб уникнути надмірного доступу до цієї змінної з області вищого рівня, ми знову дотримуємося POLE і блокуємо її у внутрішній явній блоковій області видимості.

### `var` * і *` let`

Далі поговоримо про декларацію `var buckets`. Ця змінна використовується у всій функції (за винятком остаточної інструкції `return`). Будь-яка змінна, яка потрібна для всієї функції (або більшої її частини), повинна бути оголошена так, щоб таке використання було очевидним.

| ПРИМІТКА: |
| :--- |
| Параметр `names` не використовується у всій функції, але можливості обмеження області видимості параметра не існує, тому він поводиться як декларація на рівні функції. |

То чому ми використали `var` замість `let`, для оголошення `buckets`? На те існують як семантичні, так і технічні причини.

З точки зору стилю, `var` завжди, з перших днів JS, сигналізував про "змінну, яка належить до усієї функції". Як ми стверджували в розділі "Лексична область видимості" (Глава 1), `var` приєднується до найближчої навколишньої функції, незалежно від того, де саме з'являється змінна. Це вірно, навіть якщо `var` з'являється всередині блоку:

```js
function diff(x,y) {
    if (x > y) {
        var tmp = x;    // `tmp` має функційну область видимості
        x = y;
        y = tmp;
    }

    return y - x;
}
```

Навіть попри те, що `var` знаходиться всередині блоку, вона оголошена на рівні функції (до `diff (..)`), а не блоку.

Хоча ви можете оголосити `var` всередині блоку (і при цьому надати їй функційну область видимості), я не рекомендую вам цей підхід, за винятком кількох конкретних випадків (обговорених у Додатку А). В іншому випадку, `var` слід зарезервувати для використання на верхньому рівні в функційних областях видимості.

Чому б натомість не використовувати `let` на тому самому місці? Оскільки `var` візуально відрізняється від `let` і тому наочно сигналізує: "ця змінна має функційну область видимості". Використання `let` в області видимості верхнього рівня, особливо, якщо не в перших кількох рядках функції, і коли всі інші оголошення в блоках використовують `let`, візуально не звертає уваги на різницю з оголошенням із функційною областю видимості.

Іншими словами, я відчуваю, що `var` краще повідомляю про функційну область видимості, ніж` let`, і `let` одночасно повідомляє (і забезпечує!) блокову область видимості там, де `var` недостатній. Поки вашим програмам будуть потрібні як функційні, так і блокові змінні, найбільш розумним і зручнішим для читання підходом є використання як `var`, *так і* `let` разом, але для різних цілей.

Існують інші семантичні та операційні причини вибору `var` або `let` в різних сценаріях. Ми розглянемо обставини для `var` *та* `let` більш детально в Додатку А.

| ПОПЕРЕДЖЕННЯ: |
| :--- |
| Моя рекомендація використовувати як `var` *, так і* `let` явно неоднозначна і суперечить думці більшості. Набагато частіше можна почути твердження на кшталт: "з var самі проблеми, які let виправляє" і, "ніколи не використовуй var, заміняй на let". Ці думки справедливі, але це просто думки, як і моя. `var` фактично не зламаний або не застаріло; він працював з самого початку JS, і він буде продовжувати працювати, поки JS існує. |

### Коли обирати `let`?

Моя порада лишити `var` для (переважно) лише функційної області видимості верхнього рівня означає, що в більшості інших оголошень слід використовувати `let`. Але ви все ще можете поставити собі питання, як вирішити, куди належить кожна декларація у вашій програмі?

POLE вже направляє вас до цих рішень, але давайте переконаймося, що чітко визначили правила. Спосіб прийняття рішення не залежить від того, яке ключове слово ви хочете використовувати. Спосіб вирішити - запитати себе: "Який найменший доступ буде достатнім для цієї змінної?"

Отримавши відповідь, ви дізнаєтесь, чи змінна належить до області видимості блоку або функцій. Якщо спочатку ви вирішили, що змінну слід обмежити блоком, а пізніше зрозумієте, що її потрібно підняти вище, у функцію, то це диктує зміну не лише розташування декларації цієї змінної, але й ключового слова декларатора, яке використовується. Процес прийняття рішень насправді повинен проходити так.

Якщо оголошення належить до блокової області видимості, використовуйте `let`. Якщо воно належить до області видимості всієї функції, використовуйте `var` (знову ж таки, це лише моя думка).

Але іншим способом візуалізації цього рішення є розгляд версії програми до ES6. Наприклад, згадаймо `diff(..)` з минулого розділу:

```js
function diff(x,y) {
    var tmp;

    if (x > y) {
        tmp = x;
        x = y;
        y = tmp;
    }

    return y - x;
}
```

У цій версії `diff(..)` змінну `tmp` очевидно оголошено у функційній області видимості. Це підходить для `tmp`? Я вважаю, що ні. `tmp` потрібна лише для тих кількох інструкцій. Для `return` вона не потрібна. Отже, слід обмежити її блоковою областю видимості.

До ES6 у нас не було `let`, тому ми не могли *насправді* обмежити змінну блоком. Але ми могли б зробити наступну найкращу річ, щоб повідомити про свій намір:

```js
function diff(x,y) {
    if (x > y) {
        // `tmp` досі має функційну область видимості
        // проте її розміщення семантично
        // повідомляє про блокову область видимості
        var tmp = x;
        x = y;
        y = tmp;
    }

    return y - x;
}
```

Розміщення декларації змінної `tmp` з ключовим словом `var` для  всередині `if` сигналізує читачеві коду, що `tmp` належить до цього блоку. Попри те, що JS не забезпечую блокову область видимості у цьому випадку, семантичний сигнал все одно має користь для читача вашого коду.

Виходячи з такої точки зору, ви можете знайти будь-який `var`, що знаходиться всередині блоку такого роду, і змінити його на `let`, щоб посилити семантичний сигнал, який вже надсилається. На мою думку, це правильне використання `let`.

Іншим прикладом коду, який історично використовував `var`, але який тепер майже завжди повинен обирати натомість `let`, є цикл `for`:

```js
for (var i = 0; i < 5; i++) {
    // виконати якісь дії
}
```

Незалежно від того, де такий цикл визначений, `i` завжди повинен використовуватися тільки всередині циклу, і в цьому випадку принцип POLE диктує, що його слід оголосити з `let`, а не `var`:

```js
for (let i = 0; i < 5; i++) {
    // виконати якісь дії
}
```

Майже єдиний випадок, коли заміна `var` на` let` таким чином "зламає" ваш код, це якщо ви покладаєтесь на доступ до ітератора циклу (`i`) поза циклу чи після нього, наприклад:

```js
for (var i = 0; i < 5; i++) {
    if (checkValue(i)) {
        break;
    }
}

if (i < 5) {
    console.log("The loop stopped early!");
}
```

Цей спосіб використання не є надзвичайно рідкісним, але більшість відчуває, що це схоже на погану структуру коду. Кращим підходом є використання для цього іншої змінної з зовнішньої області видимості:

```js
var lastI;

for (let i = 0; i < 5; i++) {
    lastI = i;
    if (checkValue(i)) {
        break;
    }
}

if (lastI < 5) {
    console.log("The loop stopped early!");
}
```

`lastI` потрібен у всій цій області видимості, тому він оголошений з `var`. `i` потрібне лише у кожній окремій ітерації циклу, тому воно оголошується з `let`.

### catch: особливий випадок

Наразі ми стверджували, що `var` та параметри мають функційну область видимості, а `let` та `const` сигналізують про блокові декларації. Є один невеликий виняток, який слід назвати: інструкція `catch`.

З моменту введення `try..catch` в ES3 (у 1999 р.), `catch` використовував додаткову та маловідому)можливість декларування блокової області видимості:

```js
try {
    doesntExist();
}
catch (err) {
    console.log(err);
    // ReferenceError: 'doesntExist' is not defined
    // ^^^^ повідомлення помилки, яку впіймав catch

    let onlyHere = true;
    var outerVariable = true;
}

console.log(outerVariable);     // true

console.log(err);
// ReferenceError: 'err' is not defined
// ^^^^ це інша помилка, яку не було впіймано
```

Змінна `err`, оголошена `catch`, обмежена цим блоком. Блок, створений `catch`, може містити інші декларації з блоковою областю видимості, оголошені через `let`. Але декларація `var` всередині цього блоку все одно приєднується до зовнішньої функційної або глобальної області.

ES2019 (незадовго до написання цього розділу) змінив `catch` таким чином, що оголошення є необов'язковим; якщо оголошення пропущено, блок `catch` більше не є (за замовчуванням) областю видимості; але це все-таки блок!

Отже, якщо вам потрібно відреагувати на *виняткову ситуацію*, але вас не хвилює точне значення помилки, декларацію в блоці `catch` можна опустити:

```js
try {
    doOptionOne();
}
catch {   // catch не виконує декларацію
    doOptionTwoInstead();
}
```

Це невелике, але приємне спрощення синтаксису для досить поширеного випадку використання, а також воно допомагає коду бути трохи ефективнішим завдяки видаленню непотрібної області видимості!

## Оголошення функцій у блоках (FiB)

Ми переконалися, що декларації з використанням `let` або `const` мають блокову область видимості, а декларації `var` мають функційну. То як щодо оголошень функцій, які з'являються безпосередньо всередині блоків? Цей особливий випадок називається "FiB".

Ми зазвичай думаємо про декларації функцій, як про такі, що еквівалентні декларації `var`. То чи вони також видні у всій функції навколо, як `var`?

І так, і ні. Я знаю, звучить складно. Спробуємо розібратись:

```js
if (false) {
    function ask() {
        console.log("Does this run?");
    }
}
ask();
```

Що ви очікуєте від цієї програми? Можна уявити три результати:

1. Виклик `ask()` може викинути помилку `ReferenceError`, оскільки ідентифікатор `ask` обмежений блоком `if` і, отже, недоступний з зовнішньої чи глобальної області видимості.

2. Виклик `ask()` може викинути помилку `TypeError`, оскільки ідентифікатор `ask` існує, але має значення `undefined` (оскільки інструкція `if` не виконується) і, отже, не є функцією, придатною до виклику.

3. Виклик `ask()` виконається правильно і виведе повідомлення "Does it run?".

А тепер найскладніше: залежно від того, в якому середовищі JS ви виконаєте цей фрагмент коду, ви можете отримати різні результати! Це одна з тих небагатьох шалених сфер, де наявна спадкова поведінка видає передбачуваний результат.

Специфікація JS говорить, що декларації функцій всередині блоків мають блокову область видимості, тому правильною відповіддю має бути варіант (1). Однак більшість рушіїв JS у браузерах (включаючи v8, який походить від Chrome, але також використовується в Node) буде поводитися згідно (2), тобто ідентифікатор виводиться за межі блоку `if`, але значення функції не ініціалізується автоматично, тому залишається `undefined`.

Чому JS-рушіям у браузерах дозволено поводитися всупереч специфікації? Оскільки ці рушії вже мали певну поведінку навколо FiB до того, як ES6 запровадив блокові області видимості, і існувала занепокоєність, що зміна на користь дотримання специфікації може порушити наявний код деяких вебсайтів. Таким чином, було зроблено виняток у Додатку B специфікації JS, який допускає певні відхилення для рушіїв JS у браузерах (і тільки для них!).

| ПРИМІТКА: |
| :--- |
| Ви зазвичай не класифікуєте Node як браузерне середовище JS, оскільки він зазвичай працює на сервері. Але рушій Node використовується спільно з браузерами Chrome (і Edge). Оскільки v8 спочатку був рушієм JS браузера, він приймає цей виняток Додатка B, що означає, що винятки браузера поширюються на Node. |

Одним з найпоширеніших випадків розміщення декларації функції в блоці є умовне визначення функції(наприклад, з оператором `if..else`) залежно від стану оточення. Наприклад:

```js
if (typeof Array.isArray != "undefined") {
    function isArray(a) {
        return Array.isArray(a);
    }
}
else {
    function isArray(a) {
        return Object.prototype.toString.call(a)
            == "[object Array]";
    }
}
```

Дуже спокусливою є ідея структурувати код таким чином з міркувань швидкодії, оскільки перевірка `typeof Array.isArray` виконується лише один раз, на відміну від визначення лише одного `isArray(..)` і розміщення в ньому оператора `if` - перевірки тоді буде зайвим чином запускатись при кожному виклику.

| ПОПЕРЕДЖЕННЯ: |
| :--- |
| На додаток до ризиків відхилень FiB, ще однією проблемою умовного визначення функцій є те, що таку програму складніше налагоджувати. Якщо у вас виникла помилка у функції `isArray(..)`, спочатку потрібно з'ясувати, *яка саме* реалізація  `isArray(..)` насправді запущена! Іноді помилка полягає в тому, що застосовано неправильну, оскільки умовна перевірка була неправильною! Якщо ви визначаєте декілька версій функції, цю програму завжди важче розуміти та підтримувати. |

На додаток до попередніх фрагментів, існують ще кілька вийняткових випадків, що стосуються FiB; така поведінка в різних браузерах та не браузерних середовищах JS (рушії JS, які не засновані на браузері), ймовірно, буде відрізнятися. Наприклад:

```js
if (true) {
    function ask() {
        console.log("Am I called?");
    }
}

if (true) {
    function ask() {
        console.log("Or what about me?");
    }
}

for (let i = 0; i < 5; i++) {
    function ask() {
        console.log("Or is it one of these?");
    }
}

ask();

function ask() {
    console.log("Wait, maybe, it's this one?");
}
```

Згадайте, що підняття функції, як описано в розділі "Коли я можу використовувати змінну?" (у главі 5) може навести на думку, що останній виклик `ask()` у цьому фрагменті із повідомленням "Wait, maybe...", буде піднятий над викликом `ask()`. Оскільки це остання декларація функції за цим ім'ям, вона повинна "перемогти" попередні, так? На жаль, ні.

Я не маю наміру документувати всі дивні виняткові випадки чи пояснювати, чому кожен з них поводиться певним чином. На мій погляд, ця інформація є загадковою спадщиною.

Моє справжнє занепокоєння щодо FiB полягає в тому, яку пораду я можу дати, щоб ваш код працював передбачувано за будь-яких обставин?

Щодо мене, то я вважаю, що єдиною можливістю уникнути проблем з FiB є просто повне уникнення FiB. Іншими словами, ніколи не розміщуйте оголошення функцій  безпосередньо всередині будь-якого блоку. Завжди розміщуйте декларації функцій де завгодно на верхньому рівні функційної області видимості(або в глобальній області).

Отже, для попереднього прикладу `if..else`, моя пропозиція полягає в тому, щоб уникати умовно визначення функцій, якщо це можливо. Так, це може бути трохи менш ефективним, але загалом це кращий підхід:

```js
function isArray(a) {
    if (typeof Array.isArray != "undefined") {
        return Array.isArray(a);
    }
    else {
        return Object.prototype.toString.call(a)
            == "[object Array]";
    }
}
```

Якщо цей показник швидкодії стає важливою проблемою для вашої програми, я пропоную розглянути такий підхід:

```js
var isArray = function isArray(a) {
    return Array.isArray(a);
};

// override the definition, if you must
if (typeof Array.isArray == "undefined") {
    isArray = function isArray(a) {
        return Object.prototype.toString.call(a)
            == "[object Array]";
    };
}
```

Важливо зауважити, що тут я розміщую всередині блоку `if` **функційний вираз**, а не оголошення функції. Цілком нормально і припустимо, що функційні вирази з'являються всередині блоків. Наша дискусія щодо FiB стосується уникнення **оголошень функції** в блоках.

Навіть якщо ви перевірите свою програму, і вона працюватиме коректно, незначна вигода, яку ви можете отримати від використання стилю FiB у своєму коді, не перевищує значні потенційні ризики неправильного розуміння вашого коду іншими розробниками або відхилення в тому, як код працює в інших JS середовищах.

FiB цього не вартий, і його слід уникати.

## Заблоковано

Сенс правил лексичного обсягу в мові програмування полягає в тому, що ми можемо належним чином організувати змінні нашої програми як для цілей виконання коду, так і з точки зору семантики

Одним з найважливіших організаційних методів є забезпечення того, щоб жодна змінна є доступною зайвим областям видимості (POLE). Сподіваюсь, що зараз ви цінуєте блокову область видимості більше, ніж раніше.

Також я сподіваюсь, що на цю мить у вас з'явилося міцніше розумінням лексичних областей видимості. Спираючись на цю основу, наступний розділ переходить до важливої теми замикання.

[^POLP]: *Principle of Least Privilege*, https://en.wikipedia.org/wiki/Principle_of_least_privilege, 3 March 2020.
