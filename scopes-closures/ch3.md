# You Don't Know JS Yet: області видимості та замикання - Друге видання

# Розділ 3: Ланцюжок область видимості

У 1-ому та 2-ому розділах було закладено визначення _лексичної області видимості_ (та її частин) та проілюстровано корисні метафори для її концептуального підґрунтя. Перш ніж продовжити рухатись далі, знайдіть когось, щоб пояснити своїми словами (письмово чи вголос): що таке лексична область і чому це корисно розуміти.

Це здається кроком, який можна пропустити, але я переконався, що це дійсно ефективний спосіб витратити час для переформулювання цих ідей при поясненні іншим. Це допомагає нашому мозку переварити те, що ми вивчаємо!

Тепер настав час копатись у гайках та болтах, тож очікуйте, що з цього моменту все стане набагато детальнішим. Однак дотримуйтесь думки, що всі ці розмови насправді вбивають у голову те, наскільки ми всі поки що _не знаємо_ про область видимості. Обов’язково дайте собі час на осмислення тексту та всіх наведених фрагментів коду.

Щоб оновити контекст нашого активного прикладу, давайте згадаємо кольорову ілюстрацію вкладених бульбашок області видимості, з Глави 2, Рисунок 2:

<figure>
    <img src="images/fig2.png" width="500" alt="Colored Scope Bubbles" align="center">
    <figcaption><em>Fig. 2 (Ch. 2): Colored Scope Bubbles</em></figcaption>
</figure>

Зв'язки між областями видимості, які вкладені в інші області видимості, називаються ланцюжком область видимості, який визначає шлях, по якому можна отримати доступ до змінних. Ланцюг є орієнтованим, тобто пошук шукається тільки вгору / назовні.

## "Пошук" є (переважно) концептуальним

На Рисунку 2, зверніть увагу на колір посилання змінної `студентів` у циклі` for`. Як саме ми визначили, що це ЧЕРВОНА (1) кулька?

У 2-гій главі ми описали доступ до змінної під час виконання "пошуку", де _Рушій_ повинен розпочати роботу, запитавши _Менеджера області видимості_ поточної області видимості, чи знає він про ідентифікатор / змінну, після чого рухатися вгору/назовні назад через ланцюжок вкладених областей (у напрямку до глобального масштабу), поки не буде знайдено (якщо взагалі знайдеться). Пошук зупиняється, як тільки знайдено першу відповідну іменовану декларацію у сегменті області видимості.

Таким чином, під час пошуку було визначено, що "студент" - це ЧЕРВОНА (1) кулька, оскільки ми ще не знайшли відповідного імені змінної, коли обходили ланцюжок областей видимості, поки не дійшли до остаточної ЧЕРВОНОЇ (1) глобальної області видимості.

Подібним чином, `studentID` в операторі `if` визначається як СИНЯ (2) кулька.

Ця пропозиція щодо процесу пошуку під час роботи добре працює для концептуального розуміння, але зазвичай на практиці так не відбувається.

Колір відра кульки (він же мета-інформація про те, з якої області видимості походить змінна) _зазвичай визначається_ під час початкової обробки компіляції. Оскільки лексична область видимості на той момент майже доопрацьована, колір кульки не зміниться незалежно від того, що може статися пізніше під час виконання.

Оскільки колір кульки відомий із компіляції, і він незмінний, ця інформація, швидше за все, буде зберігатися разом з (або принаймні буде доступною разом із) записом кожної змінної в Абстрактному Синтаксичному Дереві (AST); ця інформація потім буде використовуватися при виконанні інструкцій, що становлять час роботи програми.

Іншими словами, _Рушію_ (з 2-гої глави) не потрібно шукати безліч зон, щоб з'ясувати, з якого сегмента області видимості походить змінна. Ця інформація вже відома! Уникнення необхідності пошуку під час виконання є ключовою перевагою оптимізації лексичної області видимості. Час роботи використовується ефективніше без втрати часу на всі ці пошуки.

Але як я говорив: "... зазвичай визначається ...", - лише хвилину тому, щоб з'ясувати колір кульки під час складання. Тож у якому випадку це _не_ буде відомо під час компіляції?

Розглянемо посилання на змінну, яка не оголошена в жодній лексично доступній області видимості у поточному файлі - див. _Початок роботи_, 1-ший розділ, де стверджується, що кожен файл є власною окремою програмою з точки зору компіляції JS. Якщо декларації не знайдено, це _не обов'язково_ помилка. Інший файл (програма) в середовищі виконання може дійсно оголосити цю змінну у спільній глобальній області видимості.

Тож остаточне визначення, чи була змінна колись належним чином оголошена в якомусь доступному сегменті, доведеться, можливо, відкласти на час виконання.

Будь-яке посилання на змінну, яка спочатку _не оголошена_, залишається у вигляді незафарбованої кульки під час компіляції цього файлу; цей колір неможливо визначити, поки не буде скомпільовано інші відповідні файли та не почнеться час виконання програми. Цей відкладений пошук врешті-решт надасть колір області видимості, у якій знаходиться змінна (ймовірніше, глобальної області видимості).

Однак цей пошук знадобиться лише один раз для кожної змінної, оскільки згодом буде не можливо під час виконання змінити колір цієї кульки.

Розділ "Помилки пошуку" в 2-гій главі висвітлює те, що відбувається, якщо кулька в кінцевому підсумку все ще не забарвлена на момент виконання посилання.

## Затінення

"Затінення" може звучати таємничим та трохи схематичним. Але не хвилюйтеся, це цілком законно!

Наші активні приклади розділів використовують різні імена для змінних, що знаходится за межами області видимості. Оскільки всі вони мають унікальні імена, певним чином не буде значення, якщо всі вони просто зберігатимуться в одному сегменті (наприклад, ЧЕРВОНОМУ (1)).

Наявність різної лексичної області видимості починає більше значити тоді, коли у вас є дві або більше змінних, кожна з них у різних областях видимості та з однаковими лексичними назвами. У одній області видимості не може бути двох або більше змінних з однаковою назвою; такі множинні посилання можна вважати лише однією змінною.

Отже, якщо вам потрібно підтримувати дві або більше однакових змінних, ви повинні використовувати окремі (часто вкладені) області видимості. І в цьому випадку буде доречно різні розкласти області визначення як різні сегменти.

Розглянемо:

```js
var studentName = "Suzy";

function printStudent(studentName) {
  studentName = studentName.toUpperCase();
  console.log(studentName);
}

printStudent("Frank");
// FRANK

printStudent(studentName);
// SUZY

console.log(studentName);
// Suzy
```

|ПОРАДА: |

Перед тим, як піти далі, знайдіть трохи часу, щоб проаналізувати цей код, використавши різні техніки / метафори, які ми згадували в цій книзі. Зокрема, обов’язково визначте кольори кульок / оболонок у цьому фрагменті. Це хороша практика! |

Змінна `studentName` у рядку 1 (оператор` var studentName = ..`) створює ЧЕРВОНУ (1) кульку. Ця сама названа змінна оголошена як СИНЯ (2) кулька у рядку 3, параметр у визначенні функції `printStudent (..)`.

Яким кольором кульки буде `studentName` в операторі призначення`studentName = studentName.toUpperCase ()`та в операторі `console.log(studentName)`? Усі три посилання `studentName` будуть СИНІМИ (2).

З концептуальним поняттям "пошук" ми стверджували, що він починається з поточного обсягу і працює назовні/вгору і зупиняється, як тільки знайдена відповідна змінна. СИНЯ (2) `studentName` знайдена одразу. ЧЕРВОНА (1) `studentName` навіть не розглядається.

Це ключовий аспект поведінки лексичної області видимості, який називається _затінення_. СИНЯ (2) змінна `studentName` (параметр) затінює ЧЕРВОНУ (1)` studentName`. Отже, параметр затінює (затінену) глобальну змінну. Повторіть це речення кілька разів для себе, щоб переконатися, що у вас є чітка термінологія!

Ось чому повторне призначення `studentName` впливає лише на внутрішню змінну (параметр): СИНЮ (2)` studentName`, а не на глобальну ЧЕРВОНУ (1) `studentName`.

Коли ви вирішили затінити змінну із зовнішньої області видимості, прямим впливом буде те, що з цієї області видимості всередину/вниз (через будь-які вкладені області видимості) тепер неможливо жодну кульку забарвити як тіньову змінну - (ЧЕРВОНА (1) у нашому випадку). Іншими словами, будь-яке посилання на ідентифікатор `studentName` відповідатиме цій змінній параметра, і ніколи не - глобальній змінній `studentName`. Лексично неможливо посилатися на глобальне `studentName` де-небудь усередині функції `printStudent (..) `(або з будь-яких інших вкладених областей видимостей).

### Глобальний трюк без тіні

Будьте обережні: використовувати техніку, яку я збираюся описати, не дуже вдала ідея, оскільки вона має малу користь, може заплутати читачів вашого коду і, ймовірно, виникнуть помилки у вашій програмі. Я висвітлюю це лише тому, що ви можете натрапити на цю поведінку в інших програмах, і розуміння того, що відбувається,є критично важливим, щоб не спіткнутися.

Доступ до глобальної змінної можливий із області видимості, де ця змінна була затінена, але не через типове посилання на лексичний ідентифікатор.

У глобальній області видимості (ЧЕРВОНА (1)) декларація `var` та декларація `function` також представляють собою як властивості (з тим самим іменем, що і ідентифікатор) _global object_ - що, по суті, є представленням глобальної області видимості. Якщо ви написали JS для середовища браузера, ви, ймовірно, розпізнаєте глобальний об'єкт як `window`. Це не _цілком_ точно, але цілком достатньо для нашої дискусії. У наступному розділі ми докладніше розглянемо глобальну область видимості / об'єкт.

Розглянемо цю програму, що спеціально виконана як окремий файл .js у середовищі браузера:

```js
var studentName = "Suzy";

function printStudent(studentName) {
  console.log(studentName);
  console.log(window.studentName);
}

printStudent("Frank");
// "Frank"
// "Suzy"
```

Помітили посилання `window.studentName`? Цей вираз отримує доступ до глобальної змінної `studentName` як властивість у `window` (яке, на даний час будемо вважати синонімом глобального об'єкта). Це єдиний спосіб отримати доступ до тіньової змінної всередині області видимості, де присутня тінізація змінної.

`Window.studentName` є дзеркалом глобальної змінної `studentName`, а не окремою копією знімка стану системи. Зміни в одному будуть спостерігатися з іншого в двох напрямках. Ви можете уявити `window.studentName` методом читання/модифікації, який отримує доступ до фактичної змінної `studentName`. Насправді ви можете _добати_ змінну до глобальної області видимості, створивши/встановивши властивість для глобального об'єкта.

| ПОПЕРЕДЖЕННЯ: |

Пам'ятайте: те, що ви _можете_, не означає, що ви _повинні_. Не затінюйте глобальну змінну, до якої вам потрібно отримати доступ, і навпаки, уникайте використання цього трюку для доступу до глобальної змінної, яку ви затінили. І, безумовно, не плутайте читачів вашого коду, створивши глобальні змінні такі як властивості `window`, замість зовнішніх оголошень! |

Цей маленький "трюк" працює лише для доступу до глобальної змінної області видимості (не тіньової змінної від вкладеної області видимості), і тільки тоді, коли була оголошена з `var` або `function`.

Інші форми оголошення глобальної області видимості не створюють дзеркальних властивостей глобального об'єкта:

```js
var one = 1;
let notOne = 2;
const notTwo = 3;
class notThree {}

console.log(window.one); // 1
console.log(window.notOne); // undefined
console.log(window.notTwo); // undefined
console.log(window.notThree); // undefined
```

Змінні (незалежно від того, як вони оголошені!), які існують в будь-якій іншій області видимості, крім глобального, є абсолютно недоступними з області вилимості,у якій вони були затінені:

```js
var special = 42;

function lookingFor(special) {
  // The identifier `special` (parameter) in this
  // scope is shadowed inside keepLooking(), and
  // is thus inaccessible from that scope.

  // Ідентифікатор `special` (параметр) у цій
  // області визначеності затінена всередині
  // keepLooking () й т.ч., недоступна із цієї
  // області визначеності.

  function keepLooking() {
    var special = 3.141592;
    console.log(special);
    console.log(window.special);
  }

  keepLooking();
}

lookingFor(112358132134);
// 3.141592
// 42
```

Глобальний ЧЕРВОНИЙ (1) `special` затіняється СИНІМ (2) `special` (параметр), в той же час СИНІЙ (2) `special` сам затіняється ЗЕЛЕНИМ (3) `special` всередині `keepLooking ()`. Ми все ще можемо отримати доступ до ЧЕРВОНОГО (1) `special`, використваши непряме посилання `window.special`. Але `keepLooking ()` не має доступу до СИНОГО (2) `special`, що містить номер` 112358132134`.

### Копіювання це не доступ

Мене запитували наступне запитання: "А як щодо ...?" - десятки разів.
Розглянемо:

```js
var special = 42;

function lookingFor(special) {
  var another = {
    special: special,
  };

  function keepLooking() {
    var special = 3.141592;
    console.log(special);
    console.log(another.special); // Ooo, tricky!
    console.log(window.special);
  }

  keepLooking();
}

lookingFor(112358132134);
// 3.141592
// 112358132134
// 42
```

О! Чи спростовує моє твердження цей об'єкт `another` про те, що параметр `special` "повністю недоступний" зсередини `keepLooking()` ? Ні, претензія все ще існує.

`special: special` - це копіювання значення параметра змінної `special` в інший контейнер (властивість з такою ж назвою). Звісно, якщо ви покладете значення в інший контейнер, затінення більше не застосовується (якщо тільки `another` теж не був затінений!). Але це не означає, що ми отримуємо доступ до параметра `special`; це означає, що ми отримуємо доступ до копії значення, яке воно мало на той момент, за допомогою контейнера _another_ (властивість об'єкта). Ми не можемо перепризначити параметр СИНЬОГО(2) `special` у інше значення всередині `keepLooking()`.

Ще одне "Але ...!?",яке ви збираєтеся підняти: що, якби я використовував об'єкти або масиви як значення, замість цифр (`112358132134`, тощо)? Чи можна "виправити" цю недоступність, використавши посилання на об'єкти замість копій примітивних значень?

Ні. Мутація вмісту значення об’єкта за допомогою копії - це **не** те саме, що лексичний доступ до самої змінної. Ми все ще не можемо перепризначити СИНІЙ(2) параметр `special`.

### Незаконне затінення

Не всі комбінації оголошень затінення дозволені: `let` може затінити `var`, але `var` не може затінити` let`:

```js
function something() {
  var special = "JavaScript";

  {
    let special = 42; // totally fine shadowing
    // цілком срийнятно/нормальне затінення

    // ..
  }
}

function another() {
  // ..

  {
    let special = "JavaScript";

    {
      var special = "JavaScript";
      // ^^^ Syntax Error

      // ..
    }
  }
}
```

Зверніть увагу на функцію `another()`. Внутрішнє оголошення `var special` намагається оголосити загальнофункціональну `special`, що саме по собі є нормою (як показано функцією `something ()`).

Опис синтаксичної помилки в цьому випадку вказує на те, що `special` вже було визначено, але це повідомлення про помилку трохи вводить в оману. Загалом така помилка не трапляється в "something ()", оскільки затінення тут дозволяється.

Справжньою причиною `SyntaxError` є те, що `var` в основному намагається "перейти межу" (або перестрибнути) однойменної декларації `let`, що є неможливим.

Ця заборона перетину меж ефективно виконується на кожній межі функції, тому цей варіант є винятком:

```js
function another() {
  // ..

  {
    let special = "JavaScript";

    ajax("https://some.url", function callback() {
      // цілком нормальне затінення
      var special = "JavaScript";

      // ..
    });
  }
}
```

Підсумок: `let` (у внутрішній області видимості) завжди може затінити` var` зовнішньої області видимості. `var` (у внутрішній області видимості) може затінювати зовнішню область видимості `let`, лише якщо між ними є межа функції.

## Function Name Scope

## Область видимості іменованої функції

Як ви вже бачили, оголошення `function` виглядає так:

```js
function askQuestion() {
  // ..
}
```

І, як обговорювалося в 1-шому та 2-гому розділах, таке оголошення `function` створить ідентифікатор у обмеженій області видимості (у даному випадку глобальній області видимості) з назвою `askQuestion`.

А як щодо цієї програми?

```js
var askQuestion = function () {
  // ..
};
```

Те саме стосується для змінної `askQuestion`. Але оскільки вираз `function` - визначення функції, яке використовується як значення, замість самостійного оголошення, то сама функція "підніматися" не буде (див. Розділ 5).

Однією з основних відмінностей між оголошеннми `function` та виразами `function` є те, що відбувається з ідентифікатором імені функції. Розглянемо іменований вираз `function`:

```js
var askQuestion = function ofTheTeacher() {
  // ..
};
```

Ми знаємо, що `askQuestion` опиняється у зовнішній області видимості. Але як щодо ідентифікатора `ofTheTeacher`? Для формальних оголошень `function` ідентифікатор імені потрапляє у зовнішню/ обмежувальну область, тому є логічно припустити даний випадок. Але `ofTheTeacher` оголошується як ідентифікатор **всередині самої функції**:

```js
var askQuestion = function ofTheTeacher() {
  console.log(ofTheTeacher);
};

askQuestion();
// function ofTheTeacher()...

console.log(ofTheTeacher);
// ReferenceError: ofTheTeacher is not defined
```

| ПРИМІТКА: |

| Насправді, `ofTheTeacher` не є цілком _в області визначення функції._ У Додатку А, "Непрямі області видимості" буде надане пояснення.|

`OfTheTeacher` не тільки скоріше оголошується всередині функції, ніж зовні, але й також призначений лише для читання:

```js
var askQuestion = function ofTheTeacher() {
  "use strict";
  ofTheTeacher = 42; // TypeError

  //..
};

askQuestion();
// TypeError
```

Оскільки ми використали суворий режим,помилка повідомляється як `TypeError`; у несуворому режимі таке призначення мовчки провалюється без винятку.

Що відбувається, коли вираз `function` не має ідентифікатора імені?

```js
var askQuestion = function () {
  // ..
};
```

Вираз `function` з ідентифікатором імені називається "виразом іменованої функції". Відповідно той, що не має ідентифікатора імені, називається
"анонімним виразом функції". Вирази анонімних функцій безсумнівно не мають ідентифікатора імені, який впливає на ту чи іншу область видимості.

| ПРИМІТКА: |

|Ми будемо обговорювати іменовані та анонімні вирази `функції` набагато детальніше, включивши фактори, що впливають на рішення про використання того чи іншого виразу, у Додатку А.|

## Стрілочні функції

ES6 додав до мови додаткову форму вираження `function`, яка називається "стрілочні функції":

```js
var askQuestion = () => {
  // ..
};
```

Для визначення стрілочної функції `=>` не потрібно слово `function`. Крім того, `(..)` навколо списку параметрів є необов'язковим у простих випадках. Подібним чином, "{..}" навколо тіла функції в деяких випадках є необов'язковим. І коли "{..}" пропущено, повертається значення без використання ключового слова "return".

| ПРИМІТКА: |

| Привабливість функцій стрілки `=>` часто підкуповує "коротшим синтаксисом", і це, як стверджується, прирівнюється до об'єктивно більш читабельного коду. Ця заява є сумнівною, і я вважаю, що вона є абсолютно помилковою. Ми розглянемо "читабельність" різних форм функцій у Додатку А.|

Стрілочні функції є лексично анонімні, тобто вони не мають безпосередньо пов’язаного ідентифікатора, який посилається на функцію. Призначення `askQuestion` створює виведене ім'я" askQuestion ", але це **не те саме, що бути неанонімним**:

```js
var askQuestion = () => {
  // ..
};

askQuestion.name; // askQuestion
```

Стрілочні функції досягають своєї синтаксичної стислості за рахунок необхідності подумки перебирати безліч варіацій для різних форм/умов. Ось декілька, для прикладу:

```js
() => 42;

(id) => id.toUpperCase();

(id, name) => ({ id, name });

(...args) => {
  return args[args.length - 1];
};
```

Справжньою причиною того, чому я використовую стрілочні функції, є загальне, але неправильне твердження, що функції стрілок якимось чином поводяться інакше щодо лексичної області видимості на противагу стандартним функціям `function`.

Це неправильно.

Other than being anonymous (and having no declarative form), `=>` arrow functions have the same lexical scope rules as `function` functions do. An arrow function, with or without `{ .. }` around its body, still creates a separate, inner nested bucket of scope. Variable declarations inside this nested scope bucket behave the same as in a `function` scope.

За винятком того, що є анонімними (і не властиві форми оголошення), стрілочні функції `=>` мають ті самі правила лексичної області видимості, що і функції `function`. Стрілочні функції з "{..}" навколо свого тіла або без неї все одно створюють окремий внутрішній вкладений сегмент області видимості. Оголошення змінних всередині цього сегмента вкладеної області видимості поводяться так само, як і в області видимості "функції".

## Резервне копіювання

Коли функція (оголошення або вираз) визначена, створюється нова область видимості. Позиціонування областей видимості, вкладених одна в одну, створює природну ієрархію областей видимості у всій програмі, що й називається ланцюжком області видимості. Ланцюжок області видимості контролює змінний доступ, орієнтований вгору та назовні.

Кожна нова область видимості пропонує чистий аркуш, простір для зберігання власного набору змінних. Коли ім'я змінної повторюється на різних рівнях ланцюжка області видимості, відбувається затінення, яка перешкоджає доступу до зовнішньої змінної з внутрішньої частини цієї точки.

Відійшовши від цих деталізацій, наступний розділ зміщує фокус на основну область видимості, до якої входять усі програми JS: глобальна область видимості.
